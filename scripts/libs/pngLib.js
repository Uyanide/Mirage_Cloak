/*! For license information please see pngLib.js.LICENSE.txt */
!function (t, e) { "object" == typeof exports && "object" == typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define([], e) : "object" == typeof exports ? exports.pngLib = e() : t.pngLib = e() }(this, (() => (() => { "use strict"; var t = { 620: function () { !function (t) { if (t.TextEncoder && t.TextDecoder) return !1; function e(t = "utf-8") { if ("utf-8" !== t) throw new RangeError(`Failed to construct 'TextEncoder': The encoding label provided ('${t}') is invalid.`) } function r(t = "utf-8", e = { fatal: !1 }) { if ("utf-8" !== t) throw new RangeError(`Failed to construct 'TextDecoder': The encoding label provided ('${t}') is invalid.`); if (e.fatal) throw new Error("Failed to construct 'TextDecoder': the 'fatal' option is unsupported.") } Object.defineProperty(e.prototype, "encoding", { value: "utf-8" }), e.prototype.encode = function (t, e = { stream: !1 }) { if (e.stream) throw new Error("Failed to encode: the 'stream' option is unsupported."); let r = 0; const i = t.length; let n = 0, a = Math.max(32, i + (i >> 1) + 7), s = new Uint8Array(a >> 3 << 3); for (; r < i;) { let e = t.charCodeAt(r++); if (e >= 55296 && e <= 56319) { if (r < i) { const i = t.charCodeAt(r); 56320 == (64512 & i) && (++r, e = ((1023 & e) << 10) + (1023 & i) + 65536) } if (e >= 55296 && e <= 56319) continue } if (n + 4 > s.length) { a += 8, a *= 1 + r / t.length * 2, a = a >> 3 << 3; const e = new Uint8Array(a); e.set(s), s = e } if (4294967168 & e) { if (4294965248 & e) if (4294901760 & e) { if (4292870144 & e) continue; s[n++] = e >> 18 & 7 | 240, s[n++] = e >> 12 & 63 | 128, s[n++] = e >> 6 & 63 | 128 } else s[n++] = e >> 12 & 15 | 224, s[n++] = e >> 6 & 63 | 128; else s[n++] = e >> 6 & 31 | 192; s[n++] = 63 & e | 128 } else s[n++] = e } return s.slice(0, n) }, Object.defineProperty(r.prototype, "encoding", { value: "utf-8" }), Object.defineProperty(r.prototype, "fatal", { value: !1 }), Object.defineProperty(r.prototype, "ignoreBOM", { value: !1 }), r.prototype.decode = function (t, e = { stream: !1 }) { if (e.stream) throw new Error("Failed to decode: the 'stream' option is unsupported."); const r = new Uint8Array(t); let i = 0; const n = r.length, a = []; for (; i < n;) { const t = r[i++]; if (0 === t) break; if (128 & t) { if (192 == (224 & t)) { const e = 63 & r[i++]; a.push((31 & t) << 6 | e) } else if (224 == (240 & t)) { const e = 63 & r[i++], n = 63 & r[i++]; a.push((31 & t) << 12 | e << 6 | n) } else if (240 == (248 & t)) { let e = (7 & t) << 18 | (63 & r[i++]) << 12 | (63 & r[i++]) << 6 | 63 & r[i++]; e > 65535 && (e -= 65536, a.push(e >>> 10 & 1023 | 55296), e = 56320 | 1023 & e), a.push(e) } } else a.push(t) } return String.fromCharCode.apply(null, a) }, t.TextEncoder = e, t.TextDecoder = r }("undefined" != typeof window ? window : "undefined" != typeof self ? self : this) } }, e = {}; function r(i) { var n = e[i]; if (void 0 !== n) return n.exports; var a = e[i] = { exports: {} }; return t[i].call(a.exports, a, a.exports, r), a.exports } r.d = (t, e) => { for (var i in e) r.o(e, i) && !r.o(t, i) && Object.defineProperty(t, i, { enumerable: !0, get: e[i] }) }, r.o = (t, e) => Object.prototype.hasOwnProperty.call(t, e), r.r = t => { "undefined" != typeof Symbol && Symbol.toStringTag && Object.defineProperty(t, Symbol.toStringTag, { value: "Module" }), Object.defineProperty(t, "__esModule", { value: !0 }) }; var i = {}; function n(t, e = "utf8") { return new TextDecoder(e).decode(t) } r.r(i), r.d(i, { getBlobFromImageData: () => Yr, getImageDataFromImageFile: () => Gr }), r(620); const a = new TextEncoder, s = (() => { const t = new Uint8Array(4); return !((new Uint32Array(t.buffer)[0] = 1) & t[0]) })(), o = { int8: globalThis.Int8Array, uint8: globalThis.Uint8Array, int16: globalThis.Int16Array, uint16: globalThis.Uint16Array, int32: globalThis.Int32Array, uint32: globalThis.Uint32Array, uint64: globalThis.BigUint64Array, int64: globalThis.BigInt64Array, float32: globalThis.Float32Array, float64: globalThis.Float64Array }; class h { constructor(t = 8192, e = {}) { let r = !1; "number" == typeof t ? t = new ArrayBuffer(t) : (r = !0, this.lastWrittenByte = t.byteLength); const i = e.offset ? e.offset >>> 0 : 0, n = t.byteLength - i; let a = i; (ArrayBuffer.isView(t) || t instanceof h) && (t.byteLength !== t.buffer.byteLength && (a = t.byteOffset + i), t = t.buffer), this.lastWrittenByte = r ? n : 0, this.buffer = t, this.length = n, this.byteLength = n, this.byteOffset = a, this.offset = 0, this.littleEndian = !0, this._data = new DataView(this.buffer, a, n), this._mark = 0, this._marks = [] } available(t = 1) { return this.offset + t <= this.length } isLittleEndian() { return this.littleEndian } setLittleEndian() { return this.littleEndian = !0, this } isBigEndian() { return !this.littleEndian } setBigEndian() { return this.littleEndian = !1, this } skip(t = 1) { return this.offset += t, this } back(t = 1) { return this.offset -= t, this } seek(t) { return this.offset = t, this } mark() { return this._mark = this.offset, this } reset() { return this.offset = this._mark, this } pushMark() { return this._marks.push(this.offset), this } popMark() { const t = this._marks.pop(); if (void 0 === t) throw new Error("Mark stack empty"); return this.seek(t), this } rewind() { return this.offset = 0, this } ensureAvailable(t = 1) { if (!this.available(t)) { const e = 2 * (this.offset + t), r = new Uint8Array(e); r.set(new Uint8Array(this.buffer)), this.buffer = r.buffer, this.length = this.byteLength = e, this._data = new DataView(this.buffer) } return this } readBoolean() { return 0 !== this.readUint8() } readInt8() { return this._data.getInt8(this.offset++) } readUint8() { return this._data.getUint8(this.offset++) } readByte() { return this.readUint8() } readBytes(t = 1) { return this.readArray(t, "uint8") } readArray(t, e) { const r = o[e].BYTES_PER_ELEMENT * t, i = this.byteOffset + this.offset, n = this.buffer.slice(i, i + r); if (this.littleEndian === s && "uint8" !== e && "int8" !== e) { const t = new Uint8Array(this.buffer.slice(i, i + r)); t.reverse(); const n = new o[e](t.buffer); return this.offset += r, n.reverse(), n } const a = new o[e](n); return this.offset += r, a } readInt16() { const t = this._data.getInt16(this.offset, this.littleEndian); return this.offset += 2, t } readUint16() { const t = this._data.getUint16(this.offset, this.littleEndian); return this.offset += 2, t } readInt32() { const t = this._data.getInt32(this.offset, this.littleEndian); return this.offset += 4, t } readUint32() { const t = this._data.getUint32(this.offset, this.littleEndian); return this.offset += 4, t } readFloat32() { const t = this._data.getFloat32(this.offset, this.littleEndian); return this.offset += 4, t } readFloat64() { const t = this._data.getFloat64(this.offset, this.littleEndian); return this.offset += 8, t } readBigInt64() { const t = this._data.getBigInt64(this.offset, this.littleEndian); return this.offset += 8, t } readBigUint64() { const t = this._data.getBigUint64(this.offset, this.littleEndian); return this.offset += 8, t } readChar() { return String.fromCharCode(this.readInt8()) } readChars(t = 1) { let e = ""; for (let r = 0; r < t; r++)e += this.readChar(); return e } readUtf8(t = 1) { return n(this.readBytes(t)) } decodeText(t = 1, e = "utf-8") { return n(this.readBytes(t), e) } writeBoolean(t) { return this.writeUint8(t ? 255 : 0), this } writeInt8(t) { return this.ensureAvailable(1), this._data.setInt8(this.offset++, t), this._updateLastWrittenByte(), this } writeUint8(t) { return this.ensureAvailable(1), this._data.setUint8(this.offset++, t), this._updateLastWrittenByte(), this } writeByte(t) { return this.writeUint8(t) } writeBytes(t) { this.ensureAvailable(t.length); for (let e = 0; e < t.length; e++)this._data.setUint8(this.offset++, t[e]); return this._updateLastWrittenByte(), this } writeInt16(t) { return this.ensureAvailable(2), this._data.setInt16(this.offset, t, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this } writeUint16(t) { return this.ensureAvailable(2), this._data.setUint16(this.offset, t, this.littleEndian), this.offset += 2, this._updateLastWrittenByte(), this } writeInt32(t) { return this.ensureAvailable(4), this._data.setInt32(this.offset, t, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this } writeUint32(t) { return this.ensureAvailable(4), this._data.setUint32(this.offset, t, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this } writeFloat32(t) { return this.ensureAvailable(4), this._data.setFloat32(this.offset, t, this.littleEndian), this.offset += 4, this._updateLastWrittenByte(), this } writeFloat64(t) { return this.ensureAvailable(8), this._data.setFloat64(this.offset, t, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this } writeBigInt64(t) { return this.ensureAvailable(8), this._data.setBigInt64(this.offset, t, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this } writeBigUint64(t) { return this.ensureAvailable(8), this._data.setBigUint64(this.offset, t, this.littleEndian), this.offset += 8, this._updateLastWrittenByte(), this } writeChar(t) { return this.writeUint8(t.charCodeAt(0)) } writeChars(t) { for (let e = 0; e < t.length; e++)this.writeUint8(t.charCodeAt(e)); return this } writeUtf8(t) { return this.writeBytes(function (t) { return a.encode(t) }(t)) } toArray() { return new Uint8Array(this.buffer, this.byteOffset, this.lastWrittenByte) } _updateLastWrittenByte() { this.offset > this.lastWrittenByte && (this.lastWrittenByte = this.offset) } } function l(t) { let e = t.length; for (; --e >= 0;)t[e] = 0 } const d = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0]), f = new Uint8Array([0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13]), c = new Uint8Array([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7]), u = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), _ = new Array(576); l(_); const p = new Array(60); l(p); const w = new Array(512); l(w); const g = new Array(256); l(g); const b = new Array(29); l(b); const m = new Array(30); function y(t, e, r, i, n) { this.static_tree = t, this.extra_bits = e, this.extra_base = r, this.elems = i, this.max_length = n, this.has_stree = t && t.length } let v, k, E; function x(t, e) { this.dyn_tree = t, this.max_code = 0, this.stat_desc = e } l(m); const A = t => t < 256 ? w[t] : w[256 + (t >>> 7)], U = (t, e) => { t.pending_buf[t.pending++] = 255 & e, t.pending_buf[t.pending++] = e >>> 8 & 255 }, z = (t, e, r) => { t.bi_valid > 16 - r ? (t.bi_buf |= e << t.bi_valid & 65535, U(t, t.bi_buf), t.bi_buf = e >> 16 - t.bi_valid, t.bi_valid += r - 16) : (t.bi_buf |= e << t.bi_valid & 65535, t.bi_valid += r) }, R = (t, e, r) => { z(t, r[2 * e], r[2 * e + 1]) }, L = (t, e) => { let r = 0; do { r |= 1 & t, t >>>= 1, r <<= 1 } while (--e > 0); return r >>> 1 }, T = (t, e, r) => { const i = new Array(16); let n, a, s = 0; for (n = 1; n <= 15; n++)s = s + r[n - 1] << 1, i[n] = s; for (a = 0; a <= e; a++) { let e = t[2 * a + 1]; 0 !== e && (t[2 * a] = L(i[e]++, e)) } }, O = t => { let e; for (e = 0; e < 286; e++)t.dyn_ltree[2 * e] = 0; for (e = 0; e < 30; e++)t.dyn_dtree[2 * e] = 0; for (e = 0; e < 19; e++)t.bl_tree[2 * e] = 0; t.dyn_ltree[512] = 1, t.opt_len = t.static_len = 0, t.sym_next = t.matches = 0 }, N = t => { t.bi_valid > 8 ? U(t, t.bi_buf) : t.bi_valid > 0 && (t.pending_buf[t.pending++] = t.bi_buf), t.bi_buf = 0, t.bi_valid = 0 }, S = (t, e, r, i) => { const n = 2 * e, a = 2 * r; return t[n] < t[a] || t[n] === t[a] && i[e] <= i[r] }, D = (t, e, r) => { const i = t.heap[r]; let n = r << 1; for (; n <= t.heap_len && (n < t.heap_len && S(e, t.heap[n + 1], t.heap[n], t.depth) && n++, !S(e, i, t.heap[n], t.depth));)t.heap[r] = t.heap[n], r = n, n <<= 1; t.heap[r] = i }, I = (t, e, r) => { let i, n, a, s, o = 0; if (0 !== t.sym_next) do { i = 255 & t.pending_buf[t.sym_buf + o++], i += (255 & t.pending_buf[t.sym_buf + o++]) << 8, n = t.pending_buf[t.sym_buf + o++], 0 === i ? R(t, n, e) : (a = g[n], R(t, a + 256 + 1, e), s = d[a], 0 !== s && (n -= b[a], z(t, n, s)), i--, a = A(i), R(t, a, r), s = f[a], 0 !== s && (i -= m[a], z(t, i, s))) } while (o < t.sym_next); R(t, 256, e) }, B = (t, e) => { const r = e.dyn_tree, i = e.stat_desc.static_tree, n = e.stat_desc.has_stree, a = e.stat_desc.elems; let s, o, h, l = -1; for (t.heap_len = 0, t.heap_max = 573, s = 0; s < a; s++)0 !== r[2 * s] ? (t.heap[++t.heap_len] = l = s, t.depth[s] = 0) : r[2 * s + 1] = 0; for (; t.heap_len < 2;)h = t.heap[++t.heap_len] = l < 2 ? ++l : 0, r[2 * h] = 1, t.depth[h] = 0, t.opt_len--, n && (t.static_len -= i[2 * h + 1]); for (e.max_code = l, s = t.heap_len >> 1; s >= 1; s--)D(t, r, s); h = a; do { s = t.heap[1], t.heap[1] = t.heap[t.heap_len--], D(t, r, 1), o = t.heap[1], t.heap[--t.heap_max] = s, t.heap[--t.heap_max] = o, r[2 * h] = r[2 * s] + r[2 * o], t.depth[h] = (t.depth[s] >= t.depth[o] ? t.depth[s] : t.depth[o]) + 1, r[2 * s + 1] = r[2 * o + 1] = h, t.heap[1] = h++, D(t, r, 1) } while (t.heap_len >= 2); t.heap[--t.heap_max] = t.heap[1], ((t, e) => { const r = e.dyn_tree, i = e.max_code, n = e.stat_desc.static_tree, a = e.stat_desc.has_stree, s = e.stat_desc.extra_bits, o = e.stat_desc.extra_base, h = e.stat_desc.max_length; let l, d, f, c, u, _, p = 0; for (c = 0; c <= 15; c++)t.bl_count[c] = 0; for (r[2 * t.heap[t.heap_max] + 1] = 0, l = t.heap_max + 1; l < 573; l++)d = t.heap[l], c = r[2 * r[2 * d + 1] + 1] + 1, c > h && (c = h, p++), r[2 * d + 1] = c, d > i || (t.bl_count[c]++, u = 0, d >= o && (u = s[d - o]), _ = r[2 * d], t.opt_len += _ * (c + u), a && (t.static_len += _ * (n[2 * d + 1] + u))); if (0 !== p) { do { for (c = h - 1; 0 === t.bl_count[c];)c--; t.bl_count[c]--, t.bl_count[c + 1] += 2, t.bl_count[h]--, p -= 2 } while (p > 0); for (c = h; 0 !== c; c--)for (d = t.bl_count[c]; 0 !== d;)f = t.heap[--l], f > i || (r[2 * f + 1] !== c && (t.opt_len += (c - r[2 * f + 1]) * r[2 * f], r[2 * f + 1] = c), d--) } })(t, e), T(r, l, t.bl_count) }, C = (t, e, r) => { let i, n, a = -1, s = e[1], o = 0, h = 7, l = 4; for (0 === s && (h = 138, l = 3), e[2 * (r + 1) + 1] = 65535, i = 0; i <= r; i++)n = s, s = e[2 * (i + 1) + 1], ++o < h && n === s || (o < l ? t.bl_tree[2 * n] += o : 0 !== n ? (n !== a && t.bl_tree[2 * n]++, t.bl_tree[32]++) : o <= 10 ? t.bl_tree[34]++ : t.bl_tree[36]++, o = 0, a = n, 0 === s ? (h = 138, l = 3) : n === s ? (h = 6, l = 3) : (h = 7, l = 4)) }, Z = (t, e, r) => { let i, n, a = -1, s = e[1], o = 0, h = 7, l = 4; for (0 === s && (h = 138, l = 3), i = 0; i <= r; i++)if (n = s, s = e[2 * (i + 1) + 1], !(++o < h && n === s)) { if (o < l) do { R(t, n, t.bl_tree) } while (0 != --o); else 0 !== n ? (n !== a && (R(t, n, t.bl_tree), o--), R(t, 16, t.bl_tree), z(t, o - 3, 2)) : o <= 10 ? (R(t, 17, t.bl_tree), z(t, o - 3, 3)) : (R(t, 18, t.bl_tree), z(t, o - 11, 7)); o = 0, a = n, 0 === s ? (h = 138, l = 3) : n === s ? (h = 6, l = 3) : (h = 7, l = 4) } }; let F = !1; const P = (t, e, r, i) => { z(t, 0 + (i ? 1 : 0), 3), N(t), U(t, r), U(t, ~r), r && t.pending_buf.set(t.window.subarray(e, e + r), t.pending), t.pending += r }; var M = { _tr_init: t => { F || ((() => { let t, e, r, i, n; const a = new Array(16); for (r = 0, i = 0; i < 28; i++)for (b[i] = r, t = 0; t < 1 << d[i]; t++)g[r++] = i; for (g[r - 1] = i, n = 0, i = 0; i < 16; i++)for (m[i] = n, t = 0; t < 1 << f[i]; t++)w[n++] = i; for (n >>= 7; i < 30; i++)for (m[i] = n << 7, t = 0; t < 1 << f[i] - 7; t++)w[256 + n++] = i; for (e = 0; e <= 15; e++)a[e] = 0; for (t = 0; t <= 143;)_[2 * t + 1] = 8, t++, a[8]++; for (; t <= 255;)_[2 * t + 1] = 9, t++, a[9]++; for (; t <= 279;)_[2 * t + 1] = 7, t++, a[7]++; for (; t <= 287;)_[2 * t + 1] = 8, t++, a[8]++; for (T(_, 287, a), t = 0; t < 30; t++)p[2 * t + 1] = 5, p[2 * t] = L(t, 5); v = new y(_, d, 257, 286, 15), k = new y(p, f, 0, 30, 15), E = new y(new Array(0), c, 0, 19, 7) })(), F = !0), t.l_desc = new x(t.dyn_ltree, v), t.d_desc = new x(t.dyn_dtree, k), t.bl_desc = new x(t.bl_tree, E), t.bi_buf = 0, t.bi_valid = 0, O(t) }, _tr_stored_block: P, _tr_flush_block: (t, e, r, i) => { let n, a, s = 0; t.level > 0 ? (2 === t.strm.data_type && (t.strm.data_type = (t => { let e, r = 4093624447; for (e = 0; e <= 31; e++, r >>>= 1)if (1 & r && 0 !== t.dyn_ltree[2 * e]) return 0; if (0 !== t.dyn_ltree[18] || 0 !== t.dyn_ltree[20] || 0 !== t.dyn_ltree[26]) return 1; for (e = 32; e < 256; e++)if (0 !== t.dyn_ltree[2 * e]) return 1; return 0 })(t)), B(t, t.l_desc), B(t, t.d_desc), s = (t => { let e; for (C(t, t.dyn_ltree, t.l_desc.max_code), C(t, t.dyn_dtree, t.d_desc.max_code), B(t, t.bl_desc), e = 18; e >= 3 && 0 === t.bl_tree[2 * u[e] + 1]; e--); return t.opt_len += 3 * (e + 1) + 5 + 5 + 4, e })(t), n = t.opt_len + 3 + 7 >>> 3, a = t.static_len + 3 + 7 >>> 3, a <= n && (n = a)) : n = a = r + 5, r + 4 <= n && -1 !== e ? P(t, e, r, i) : 4 === t.strategy || a === n ? (z(t, 2 + (i ? 1 : 0), 3), I(t, _, p)) : (z(t, 4 + (i ? 1 : 0), 3), ((t, e, r, i) => { let n; for (z(t, e - 257, 5), z(t, r - 1, 5), z(t, i - 4, 4), n = 0; n < i; n++)z(t, t.bl_tree[2 * u[n] + 1], 3); Z(t, t.dyn_ltree, e - 1), Z(t, t.dyn_dtree, r - 1) })(t, t.l_desc.max_code + 1, t.d_desc.max_code + 1, s + 1), I(t, t.dyn_ltree, t.dyn_dtree)), O(t), i && N(t) }, _tr_tally: (t, e, r) => (t.pending_buf[t.sym_buf + t.sym_next++] = e, t.pending_buf[t.sym_buf + t.sym_next++] = e >> 8, t.pending_buf[t.sym_buf + t.sym_next++] = r, 0 === e ? t.dyn_ltree[2 * r]++ : (t.matches++, e--, t.dyn_ltree[2 * (g[r] + 256 + 1)]++, t.dyn_dtree[2 * A(e)]++), t.sym_next === t.sym_end), _tr_align: t => { z(t, 2, 3), R(t, 256, _), (t => { 16 === t.bi_valid ? (U(t, t.bi_buf), t.bi_buf = 0, t.bi_valid = 0) : t.bi_valid >= 8 && (t.pending_buf[t.pending++] = 255 & t.bi_buf, t.bi_buf >>= 8, t.bi_valid -= 8) })(t) } }, H = (t, e, r, i) => { let n = 65535 & t, a = t >>> 16 & 65535, s = 0; for (; 0 !== r;) { s = r > 2e3 ? 2e3 : r, r -= s; do { n = n + e[i++] | 0, a = a + n | 0 } while (--s); n %= 65521, a %= 65521 } return n | a << 16 }; const j = new Uint32Array((() => { let t, e = []; for (var r = 0; r < 256; r++) { t = r; for (var i = 0; i < 8; i++)t = 1 & t ? 3988292384 ^ t >>> 1 : t >>> 1; e[r] = t } return e })()); var W = (t, e, r, i) => { const n = j, a = i + r; t ^= -1; for (let r = i; r < a; r++)t = t >>> 8 ^ n[255 & (t ^ e[r])]; return ~t }, K = { 2: "need dictionary", 1: "stream end", 0: "", "-1": "file error", "-2": "stream error", "-3": "data error", "-4": "insufficient memory", "-5": "buffer error", "-6": "incompatible version" }, $ = { Z_NO_FLUSH: 0, Z_PARTIAL_FLUSH: 1, Z_SYNC_FLUSH: 2, Z_FULL_FLUSH: 3, Z_FINISH: 4, Z_BLOCK: 5, Z_TREES: 6, Z_OK: 0, Z_STREAM_END: 1, Z_NEED_DICT: 2, Z_ERRNO: -1, Z_STREAM_ERROR: -2, Z_DATA_ERROR: -3, Z_MEM_ERROR: -4, Z_BUF_ERROR: -5, Z_NO_COMPRESSION: 0, Z_BEST_SPEED: 1, Z_BEST_COMPRESSION: 9, Z_DEFAULT_COMPRESSION: -1, Z_FILTERED: 1, Z_HUFFMAN_ONLY: 2, Z_RLE: 3, Z_FIXED: 4, Z_DEFAULT_STRATEGY: 0, Z_BINARY: 0, Z_TEXT: 1, Z_UNKNOWN: 2, Z_DEFLATED: 8 }; const { _tr_init: G, _tr_stored_block: Y, _tr_flush_block: X, _tr_tally: V, _tr_align: q } = M, { Z_NO_FLUSH: J, Z_PARTIAL_FLUSH: Q, Z_FULL_FLUSH: tt, Z_FINISH: et, Z_BLOCK: rt, Z_OK: it, Z_STREAM_END: nt, Z_STREAM_ERROR: at, Z_DATA_ERROR: st, Z_BUF_ERROR: ot, Z_DEFAULT_COMPRESSION: ht, Z_FILTERED: lt, Z_HUFFMAN_ONLY: dt, Z_RLE: ft, Z_FIXED: ct, Z_DEFAULT_STRATEGY: ut, Z_UNKNOWN: _t, Z_DEFLATED: pt } = $, wt = 258, gt = 262, bt = 42, mt = 113, yt = 666, vt = (t, e) => (t.msg = K[e], e), kt = t => 2 * t - (t > 4 ? 9 : 0), Et = t => { let e = t.length; for (; --e >= 0;)t[e] = 0 }, xt = t => { let e, r, i, n = t.w_size; e = t.hash_size, i = e; do { r = t.head[--i], t.head[i] = r >= n ? r - n : 0 } while (--e); e = n, i = e; do { r = t.prev[--i], t.prev[i] = r >= n ? r - n : 0 } while (--e) }; let At = (t, e, r) => (e << t.hash_shift ^ r) & t.hash_mask; const Ut = t => { const e = t.state; let r = e.pending; r > t.avail_out && (r = t.avail_out), 0 !== r && (t.output.set(e.pending_buf.subarray(e.pending_out, e.pending_out + r), t.next_out), t.next_out += r, e.pending_out += r, t.total_out += r, t.avail_out -= r, e.pending -= r, 0 === e.pending && (e.pending_out = 0)) }, zt = (t, e) => { X(t, t.block_start >= 0 ? t.block_start : -1, t.strstart - t.block_start, e), t.block_start = t.strstart, Ut(t.strm) }, Rt = (t, e) => { t.pending_buf[t.pending++] = e }, Lt = (t, e) => { t.pending_buf[t.pending++] = e >>> 8 & 255, t.pending_buf[t.pending++] = 255 & e }, Tt = (t, e, r, i) => { let n = t.avail_in; return n > i && (n = i), 0 === n ? 0 : (t.avail_in -= n, e.set(t.input.subarray(t.next_in, t.next_in + n), r), 1 === t.state.wrap ? t.adler = H(t.adler, e, n, r) : 2 === t.state.wrap && (t.adler = W(t.adler, e, n, r)), t.next_in += n, t.total_in += n, n) }, Ot = (t, e) => { let r, i, n = t.max_chain_length, a = t.strstart, s = t.prev_length, o = t.nice_match; const h = t.strstart > t.w_size - gt ? t.strstart - (t.w_size - gt) : 0, l = t.window, d = t.w_mask, f = t.prev, c = t.strstart + wt; let u = l[a + s - 1], _ = l[a + s]; t.prev_length >= t.good_match && (n >>= 2), o > t.lookahead && (o = t.lookahead); do { if (r = e, l[r + s] === _ && l[r + s - 1] === u && l[r] === l[a] && l[++r] === l[a + 1]) { a += 2, r++; do { } while (l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && l[++a] === l[++r] && a < c); if (i = wt - (c - a), a = c - wt, i > s) { if (t.match_start = e, s = i, i >= o) break; u = l[a + s - 1], _ = l[a + s] } } } while ((e = f[e & d]) > h && 0 != --n); return s <= t.lookahead ? s : t.lookahead }, Nt = t => { const e = t.w_size; let r, i, n; do { if (i = t.window_size - t.lookahead - t.strstart, t.strstart >= e + (e - gt) && (t.window.set(t.window.subarray(e, e + e - i), 0), t.match_start -= e, t.strstart -= e, t.block_start -= e, t.insert > t.strstart && (t.insert = t.strstart), xt(t), i += e), 0 === t.strm.avail_in) break; if (r = Tt(t.strm, t.window, t.strstart + t.lookahead, i), t.lookahead += r, t.lookahead + t.insert >= 3) for (n = t.strstart - t.insert, t.ins_h = t.window[n], t.ins_h = At(t, t.ins_h, t.window[n + 1]); t.insert && (t.ins_h = At(t, t.ins_h, t.window[n + 3 - 1]), t.prev[n & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = n, n++, t.insert--, !(t.lookahead + t.insert < 3));); } while (t.lookahead < gt && 0 !== t.strm.avail_in) }, St = (t, e) => { let r, i, n, a = t.pending_buf_size - 5 > t.w_size ? t.w_size : t.pending_buf_size - 5, s = 0, o = t.strm.avail_in; do { if (r = 65535, n = t.bi_valid + 42 >> 3, t.strm.avail_out < n) break; if (n = t.strm.avail_out - n, i = t.strstart - t.block_start, r > i + t.strm.avail_in && (r = i + t.strm.avail_in), r > n && (r = n), r < a && (0 === r && e !== et || e === J || r !== i + t.strm.avail_in)) break; s = e === et && r === i + t.strm.avail_in ? 1 : 0, Y(t, 0, 0, s), t.pending_buf[t.pending - 4] = r, t.pending_buf[t.pending - 3] = r >> 8, t.pending_buf[t.pending - 2] = ~r, t.pending_buf[t.pending - 1] = ~r >> 8, Ut(t.strm), i && (i > r && (i = r), t.strm.output.set(t.window.subarray(t.block_start, t.block_start + i), t.strm.next_out), t.strm.next_out += i, t.strm.avail_out -= i, t.strm.total_out += i, t.block_start += i, r -= i), r && (Tt(t.strm, t.strm.output, t.strm.next_out, r), t.strm.next_out += r, t.strm.avail_out -= r, t.strm.total_out += r) } while (0 === s); return o -= t.strm.avail_in, o && (o >= t.w_size ? (t.matches = 2, t.window.set(t.strm.input.subarray(t.strm.next_in - t.w_size, t.strm.next_in), 0), t.strstart = t.w_size, t.insert = t.strstart) : (t.window_size - t.strstart <= o && (t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, t.insert > t.strstart && (t.insert = t.strstart)), t.window.set(t.strm.input.subarray(t.strm.next_in - o, t.strm.next_in), t.strstart), t.strstart += o, t.insert += o > t.w_size - t.insert ? t.w_size - t.insert : o), t.block_start = t.strstart), t.high_water < t.strstart && (t.high_water = t.strstart), s ? 4 : e !== J && e !== et && 0 === t.strm.avail_in && t.strstart === t.block_start ? 2 : (n = t.window_size - t.strstart, t.strm.avail_in > n && t.block_start >= t.w_size && (t.block_start -= t.w_size, t.strstart -= t.w_size, t.window.set(t.window.subarray(t.w_size, t.w_size + t.strstart), 0), t.matches < 2 && t.matches++, n += t.w_size, t.insert > t.strstart && (t.insert = t.strstart)), n > t.strm.avail_in && (n = t.strm.avail_in), n && (Tt(t.strm, t.window, t.strstart, n), t.strstart += n, t.insert += n > t.w_size - t.insert ? t.w_size - t.insert : n), t.high_water < t.strstart && (t.high_water = t.strstart), n = t.bi_valid + 42 >> 3, n = t.pending_buf_size - n > 65535 ? 65535 : t.pending_buf_size - n, a = n > t.w_size ? t.w_size : n, i = t.strstart - t.block_start, (i >= a || (i || e === et) && e !== J && 0 === t.strm.avail_in && i <= n) && (r = i > n ? n : i, s = e === et && 0 === t.strm.avail_in && r === i ? 1 : 0, Y(t, t.block_start, r, s), t.block_start += r, Ut(t.strm)), s ? 3 : 1) }, Dt = (t, e) => { let r, i; for (; ;) { if (t.lookahead < gt) { if (Nt(t), t.lookahead < gt && e === J) return 1; if (0 === t.lookahead) break } if (r = 0, t.lookahead >= 3 && (t.ins_h = At(t, t.ins_h, t.window[t.strstart + 3 - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), 0 !== r && t.strstart - r <= t.w_size - gt && (t.match_length = Ot(t, r)), t.match_length >= 3) if (i = V(t, t.strstart - t.match_start, t.match_length - 3), t.lookahead -= t.match_length, t.match_length <= t.max_lazy_match && t.lookahead >= 3) { t.match_length--; do { t.strstart++, t.ins_h = At(t, t.ins_h, t.window[t.strstart + 3 - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart } while (0 != --t.match_length); t.strstart++ } else t.strstart += t.match_length, t.match_length = 0, t.ins_h = t.window[t.strstart], t.ins_h = At(t, t.ins_h, t.window[t.strstart + 1]); else i = V(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++; if (i && (zt(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = t.strstart < 2 ? t.strstart : 2, e === et ? (zt(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (zt(t, !1), 0 === t.strm.avail_out) ? 1 : 2 }, It = (t, e) => { let r, i, n; for (; ;) { if (t.lookahead < gt) { if (Nt(t), t.lookahead < gt && e === J) return 1; if (0 === t.lookahead) break } if (r = 0, t.lookahead >= 3 && (t.ins_h = At(t, t.ins_h, t.window[t.strstart + 3 - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart), t.prev_length = t.match_length, t.prev_match = t.match_start, t.match_length = 2, 0 !== r && t.prev_length < t.max_lazy_match && t.strstart - r <= t.w_size - gt && (t.match_length = Ot(t, r), t.match_length <= 5 && (t.strategy === lt || 3 === t.match_length && t.strstart - t.match_start > 4096) && (t.match_length = 2)), t.prev_length >= 3 && t.match_length <= t.prev_length) { n = t.strstart + t.lookahead - 3, i = V(t, t.strstart - 1 - t.prev_match, t.prev_length - 3), t.lookahead -= t.prev_length - 1, t.prev_length -= 2; do { ++t.strstart <= n && (t.ins_h = At(t, t.ins_h, t.window[t.strstart + 3 - 1]), r = t.prev[t.strstart & t.w_mask] = t.head[t.ins_h], t.head[t.ins_h] = t.strstart) } while (0 != --t.prev_length); if (t.match_available = 0, t.match_length = 2, t.strstart++, i && (zt(t, !1), 0 === t.strm.avail_out)) return 1 } else if (t.match_available) { if (i = V(t, 0, t.window[t.strstart - 1]), i && zt(t, !1), t.strstart++, t.lookahead--, 0 === t.strm.avail_out) return 1 } else t.match_available = 1, t.strstart++, t.lookahead-- } return t.match_available && (i = V(t, 0, t.window[t.strstart - 1]), t.match_available = 0), t.insert = t.strstart < 2 ? t.strstart : 2, e === et ? (zt(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (zt(t, !1), 0 === t.strm.avail_out) ? 1 : 2 }; function Bt(t, e, r, i, n) { this.good_length = t, this.max_lazy = e, this.nice_length = r, this.max_chain = i, this.func = n } const Ct = [new Bt(0, 0, 0, 0, St), new Bt(4, 4, 8, 4, Dt), new Bt(4, 5, 16, 8, Dt), new Bt(4, 6, 32, 32, Dt), new Bt(4, 4, 16, 16, It), new Bt(8, 16, 32, 32, It), new Bt(8, 16, 128, 128, It), new Bt(8, 32, 128, 256, It), new Bt(32, 128, 258, 1024, It), new Bt(32, 258, 258, 4096, It)]; function Zt() { this.strm = null, this.status = 0, this.pending_buf = null, this.pending_buf_size = 0, this.pending_out = 0, this.pending = 0, this.wrap = 0, this.gzhead = null, this.gzindex = 0, this.method = pt, this.last_flush = -1, this.w_size = 0, this.w_bits = 0, this.w_mask = 0, this.window = null, this.window_size = 0, this.prev = null, this.head = null, this.ins_h = 0, this.hash_size = 0, this.hash_bits = 0, this.hash_mask = 0, this.hash_shift = 0, this.block_start = 0, this.match_length = 0, this.prev_match = 0, this.match_available = 0, this.strstart = 0, this.match_start = 0, this.lookahead = 0, this.prev_length = 0, this.max_chain_length = 0, this.max_lazy_match = 0, this.level = 0, this.strategy = 0, this.good_match = 0, this.nice_match = 0, this.dyn_ltree = new Uint16Array(1146), this.dyn_dtree = new Uint16Array(122), this.bl_tree = new Uint16Array(78), Et(this.dyn_ltree), Et(this.dyn_dtree), Et(this.bl_tree), this.l_desc = null, this.d_desc = null, this.bl_desc = null, this.bl_count = new Uint16Array(16), this.heap = new Uint16Array(573), Et(this.heap), this.heap_len = 0, this.heap_max = 0, this.depth = new Uint16Array(573), Et(this.depth), this.sym_buf = 0, this.lit_bufsize = 0, this.sym_next = 0, this.sym_end = 0, this.opt_len = 0, this.static_len = 0, this.matches = 0, this.insert = 0, this.bi_buf = 0, this.bi_valid = 0 } const Ft = t => { if (!t) return 1; const e = t.state; return !e || e.strm !== t || e.status !== bt && 57 !== e.status && 69 !== e.status && 73 !== e.status && 91 !== e.status && 103 !== e.status && e.status !== mt && e.status !== yt ? 1 : 0 }, Pt = t => { if (Ft(t)) return vt(t, at); t.total_in = t.total_out = 0, t.data_type = _t; const e = t.state; return e.pending = 0, e.pending_out = 0, e.wrap < 0 && (e.wrap = -e.wrap), e.status = 2 === e.wrap ? 57 : e.wrap ? bt : mt, t.adler = 2 === e.wrap ? 0 : 1, e.last_flush = -2, G(e), it }, Mt = t => { const e = Pt(t); var r; return e === it && ((r = t.state).window_size = 2 * r.w_size, Et(r.head), r.max_lazy_match = Ct[r.level].max_lazy, r.good_match = Ct[r.level].good_length, r.nice_match = Ct[r.level].nice_length, r.max_chain_length = Ct[r.level].max_chain, r.strstart = 0, r.block_start = 0, r.lookahead = 0, r.insert = 0, r.match_length = r.prev_length = 2, r.match_available = 0, r.ins_h = 0), e }, Ht = (t, e, r, i, n, a) => { if (!t) return at; let s = 1; if (e === ht && (e = 6), i < 0 ? (s = 0, i = -i) : i > 15 && (s = 2, i -= 16), n < 1 || n > 9 || r !== pt || i < 8 || i > 15 || e < 0 || e > 9 || a < 0 || a > ct || 8 === i && 1 !== s) return vt(t, at); 8 === i && (i = 9); const o = new Zt; return t.state = o, o.strm = t, o.status = bt, o.wrap = s, o.gzhead = null, o.w_bits = i, o.w_size = 1 << o.w_bits, o.w_mask = o.w_size - 1, o.hash_bits = n + 7, o.hash_size = 1 << o.hash_bits, o.hash_mask = o.hash_size - 1, o.hash_shift = ~~((o.hash_bits + 3 - 1) / 3), o.window = new Uint8Array(2 * o.w_size), o.head = new Uint16Array(o.hash_size), o.prev = new Uint16Array(o.w_size), o.lit_bufsize = 1 << n + 6, o.pending_buf_size = 4 * o.lit_bufsize, o.pending_buf = new Uint8Array(o.pending_buf_size), o.sym_buf = o.lit_bufsize, o.sym_end = 3 * (o.lit_bufsize - 1), o.level = e, o.strategy = a, o.method = r, Mt(t) }; var jt = { deflateInit: (t, e) => Ht(t, e, pt, 15, 8, ut), deflateInit2: Ht, deflateReset: Mt, deflateResetKeep: Pt, deflateSetHeader: (t, e) => Ft(t) || 2 !== t.state.wrap ? at : (t.state.gzhead = e, it), deflate: (t, e) => { if (Ft(t) || e > rt || e < 0) return t ? vt(t, at) : at; const r = t.state; if (!t.output || 0 !== t.avail_in && !t.input || r.status === yt && e !== et) return vt(t, 0 === t.avail_out ? ot : at); const i = r.last_flush; if (r.last_flush = e, 0 !== r.pending) { if (Ut(t), 0 === t.avail_out) return r.last_flush = -1, it } else if (0 === t.avail_in && kt(e) <= kt(i) && e !== et) return vt(t, ot); if (r.status === yt && 0 !== t.avail_in) return vt(t, ot); if (r.status === bt && 0 === r.wrap && (r.status = mt), r.status === bt) { let e = pt + (r.w_bits - 8 << 4) << 8, i = -1; if (i = r.strategy >= dt || r.level < 2 ? 0 : r.level < 6 ? 1 : 6 === r.level ? 2 : 3, e |= i << 6, 0 !== r.strstart && (e |= 32), e += 31 - e % 31, Lt(r, e), 0 !== r.strstart && (Lt(r, t.adler >>> 16), Lt(r, 65535 & t.adler)), t.adler = 1, r.status = mt, Ut(t), 0 !== r.pending) return r.last_flush = -1, it } if (57 === r.status) if (t.adler = 0, Rt(r, 31), Rt(r, 139), Rt(r, 8), r.gzhead) Rt(r, (r.gzhead.text ? 1 : 0) + (r.gzhead.hcrc ? 2 : 0) + (r.gzhead.extra ? 4 : 0) + (r.gzhead.name ? 8 : 0) + (r.gzhead.comment ? 16 : 0)), Rt(r, 255 & r.gzhead.time), Rt(r, r.gzhead.time >> 8 & 255), Rt(r, r.gzhead.time >> 16 & 255), Rt(r, r.gzhead.time >> 24 & 255), Rt(r, 9 === r.level ? 2 : r.strategy >= dt || r.level < 2 ? 4 : 0), Rt(r, 255 & r.gzhead.os), r.gzhead.extra && r.gzhead.extra.length && (Rt(r, 255 & r.gzhead.extra.length), Rt(r, r.gzhead.extra.length >> 8 & 255)), r.gzhead.hcrc && (t.adler = W(t.adler, r.pending_buf, r.pending, 0)), r.gzindex = 0, r.status = 69; else if (Rt(r, 0), Rt(r, 0), Rt(r, 0), Rt(r, 0), Rt(r, 0), Rt(r, 9 === r.level ? 2 : r.strategy >= dt || r.level < 2 ? 4 : 0), Rt(r, 3), r.status = mt, Ut(t), 0 !== r.pending) return r.last_flush = -1, it; if (69 === r.status) { if (r.gzhead.extra) { let e = r.pending, i = (65535 & r.gzhead.extra.length) - r.gzindex; for (; r.pending + i > r.pending_buf_size;) { let n = r.pending_buf_size - r.pending; if (r.pending_buf.set(r.gzhead.extra.subarray(r.gzindex, r.gzindex + n), r.pending), r.pending = r.pending_buf_size, r.gzhead.hcrc && r.pending > e && (t.adler = W(t.adler, r.pending_buf, r.pending - e, e)), r.gzindex += n, Ut(t), 0 !== r.pending) return r.last_flush = -1, it; e = 0, i -= n } let n = new Uint8Array(r.gzhead.extra); r.pending_buf.set(n.subarray(r.gzindex, r.gzindex + i), r.pending), r.pending += i, r.gzhead.hcrc && r.pending > e && (t.adler = W(t.adler, r.pending_buf, r.pending - e, e)), r.gzindex = 0 } r.status = 73 } if (73 === r.status) { if (r.gzhead.name) { let e, i = r.pending; do { if (r.pending === r.pending_buf_size) { if (r.gzhead.hcrc && r.pending > i && (t.adler = W(t.adler, r.pending_buf, r.pending - i, i)), Ut(t), 0 !== r.pending) return r.last_flush = -1, it; i = 0 } e = r.gzindex < r.gzhead.name.length ? 255 & r.gzhead.name.charCodeAt(r.gzindex++) : 0, Rt(r, e) } while (0 !== e); r.gzhead.hcrc && r.pending > i && (t.adler = W(t.adler, r.pending_buf, r.pending - i, i)), r.gzindex = 0 } r.status = 91 } if (91 === r.status) { if (r.gzhead.comment) { let e, i = r.pending; do { if (r.pending === r.pending_buf_size) { if (r.gzhead.hcrc && r.pending > i && (t.adler = W(t.adler, r.pending_buf, r.pending - i, i)), Ut(t), 0 !== r.pending) return r.last_flush = -1, it; i = 0 } e = r.gzindex < r.gzhead.comment.length ? 255 & r.gzhead.comment.charCodeAt(r.gzindex++) : 0, Rt(r, e) } while (0 !== e); r.gzhead.hcrc && r.pending > i && (t.adler = W(t.adler, r.pending_buf, r.pending - i, i)) } r.status = 103 } if (103 === r.status) { if (r.gzhead.hcrc) { if (r.pending + 2 > r.pending_buf_size && (Ut(t), 0 !== r.pending)) return r.last_flush = -1, it; Rt(r, 255 & t.adler), Rt(r, t.adler >> 8 & 255), t.adler = 0 } if (r.status = mt, Ut(t), 0 !== r.pending) return r.last_flush = -1, it } if (0 !== t.avail_in || 0 !== r.lookahead || e !== J && r.status !== yt) { let i = 0 === r.level ? St(r, e) : r.strategy === dt ? ((t, e) => { let r; for (; ;) { if (0 === t.lookahead && (Nt(t), 0 === t.lookahead)) { if (e === J) return 1; break } if (t.match_length = 0, r = V(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++, r && (zt(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = 0, e === et ? (zt(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (zt(t, !1), 0 === t.strm.avail_out) ? 1 : 2 })(r, e) : r.strategy === ft ? ((t, e) => { let r, i, n, a; const s = t.window; for (; ;) { if (t.lookahead <= wt) { if (Nt(t), t.lookahead <= wt && e === J) return 1; if (0 === t.lookahead) break } if (t.match_length = 0, t.lookahead >= 3 && t.strstart > 0 && (n = t.strstart - 1, i = s[n], i === s[++n] && i === s[++n] && i === s[++n])) { a = t.strstart + wt; do { } while (i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && i === s[++n] && n < a); t.match_length = wt - (a - n), t.match_length > t.lookahead && (t.match_length = t.lookahead) } if (t.match_length >= 3 ? (r = V(t, 1, t.match_length - 3), t.lookahead -= t.match_length, t.strstart += t.match_length, t.match_length = 0) : (r = V(t, 0, t.window[t.strstart]), t.lookahead--, t.strstart++), r && (zt(t, !1), 0 === t.strm.avail_out)) return 1 } return t.insert = 0, e === et ? (zt(t, !0), 0 === t.strm.avail_out ? 3 : 4) : t.sym_next && (zt(t, !1), 0 === t.strm.avail_out) ? 1 : 2 })(r, e) : Ct[r.level].func(r, e); if (3 !== i && 4 !== i || (r.status = yt), 1 === i || 3 === i) return 0 === t.avail_out && (r.last_flush = -1), it; if (2 === i && (e === Q ? q(r) : e !== rt && (Y(r, 0, 0, !1), e === tt && (Et(r.head), 0 === r.lookahead && (r.strstart = 0, r.block_start = 0, r.insert = 0))), Ut(t), 0 === t.avail_out)) return r.last_flush = -1, it } return e !== et ? it : r.wrap <= 0 ? nt : (2 === r.wrap ? (Rt(r, 255 & t.adler), Rt(r, t.adler >> 8 & 255), Rt(r, t.adler >> 16 & 255), Rt(r, t.adler >> 24 & 255), Rt(r, 255 & t.total_in), Rt(r, t.total_in >> 8 & 255), Rt(r, t.total_in >> 16 & 255), Rt(r, t.total_in >> 24 & 255)) : (Lt(r, t.adler >>> 16), Lt(r, 65535 & t.adler)), Ut(t), r.wrap > 0 && (r.wrap = -r.wrap), 0 !== r.pending ? it : nt) }, deflateEnd: t => { if (Ft(t)) return at; const e = t.state.status; return t.state = null, e === mt ? vt(t, st) : it }, deflateSetDictionary: (t, e) => { let r = e.length; if (Ft(t)) return at; const i = t.state, n = i.wrap; if (2 === n || 1 === n && i.status !== bt || i.lookahead) return at; if (1 === n && (t.adler = H(t.adler, e, r, 0)), i.wrap = 0, r >= i.w_size) { 0 === n && (Et(i.head), i.strstart = 0, i.block_start = 0, i.insert = 0); let t = new Uint8Array(i.w_size); t.set(e.subarray(r - i.w_size, r), 0), e = t, r = i.w_size } const a = t.avail_in, s = t.next_in, o = t.input; for (t.avail_in = r, t.next_in = 0, t.input = e, Nt(i); i.lookahead >= 3;) { let t = i.strstart, e = i.lookahead - 2; do { i.ins_h = At(i, i.ins_h, i.window[t + 3 - 1]), i.prev[t & i.w_mask] = i.head[i.ins_h], i.head[i.ins_h] = t, t++ } while (--e); i.strstart = t, i.lookahead = 2, Nt(i) } return i.strstart += i.lookahead, i.block_start = i.strstart, i.insert = i.lookahead, i.lookahead = 0, i.match_length = i.prev_length = 2, i.match_available = 0, t.next_in = s, t.input = o, t.avail_in = a, i.wrap = n, it }, deflateInfo: "pako deflate (from Nodeca project)" }; const Wt = (t, e) => Object.prototype.hasOwnProperty.call(t, e); var Kt = { assign: function (t) { const e = Array.prototype.slice.call(arguments, 1); for (; e.length;) { const r = e.shift(); if (r) { if ("object" != typeof r) throw new TypeError(r + "must be non-object"); for (const e in r) Wt(r, e) && (t[e] = r[e]) } } return t }, flattenChunks: t => { let e = 0; for (let r = 0, i = t.length; r < i; r++)e += t[r].length; const r = new Uint8Array(e); for (let e = 0, i = 0, n = t.length; e < n; e++) { let n = t[e]; r.set(n, i), i += n.length } return r } }; let $t = !0; try { String.fromCharCode.apply(null, new Uint8Array(1)) } catch (t) { $t = !1 } const Gt = new Uint8Array(256); for (let t = 0; t < 256; t++)Gt[t] = t >= 252 ? 6 : t >= 248 ? 5 : t >= 240 ? 4 : t >= 224 ? 3 : t >= 192 ? 2 : 1; Gt[254] = Gt[254] = 1; var Yt = { string2buf: t => { if ("function" == typeof TextEncoder && TextEncoder.prototype.encode) return (new TextEncoder).encode(t); let e, r, i, n, a, s = t.length, o = 0; for (n = 0; n < s; n++)r = t.charCodeAt(n), 55296 == (64512 & r) && n + 1 < s && (i = t.charCodeAt(n + 1), 56320 == (64512 & i) && (r = 65536 + (r - 55296 << 10) + (i - 56320), n++)), o += r < 128 ? 1 : r < 2048 ? 2 : r < 65536 ? 3 : 4; for (e = new Uint8Array(o), a = 0, n = 0; a < o; n++)r = t.charCodeAt(n), 55296 == (64512 & r) && n + 1 < s && (i = t.charCodeAt(n + 1), 56320 == (64512 & i) && (r = 65536 + (r - 55296 << 10) + (i - 56320), n++)), r < 128 ? e[a++] = r : r < 2048 ? (e[a++] = 192 | r >>> 6, e[a++] = 128 | 63 & r) : r < 65536 ? (e[a++] = 224 | r >>> 12, e[a++] = 128 | r >>> 6 & 63, e[a++] = 128 | 63 & r) : (e[a++] = 240 | r >>> 18, e[a++] = 128 | r >>> 12 & 63, e[a++] = 128 | r >>> 6 & 63, e[a++] = 128 | 63 & r); return e }, buf2string: (t, e) => { const r = e || t.length; if ("function" == typeof TextDecoder && TextDecoder.prototype.decode) return (new TextDecoder).decode(t.subarray(0, e)); let i, n; const a = new Array(2 * r); for (n = 0, i = 0; i < r;) { let e = t[i++]; if (e < 128) { a[n++] = e; continue } let s = Gt[e]; if (s > 4) a[n++] = 65533, i += s - 1; else { for (e &= 2 === s ? 31 : 3 === s ? 15 : 7; s > 1 && i < r;)e = e << 6 | 63 & t[i++], s--; s > 1 ? a[n++] = 65533 : e < 65536 ? a[n++] = e : (e -= 65536, a[n++] = 55296 | e >> 10 & 1023, a[n++] = 56320 | 1023 & e) } } return ((t, e) => { if (e < 65534 && t.subarray && $t) return String.fromCharCode.apply(null, t.length === e ? t : t.subarray(0, e)); let r = ""; for (let i = 0; i < e; i++)r += String.fromCharCode(t[i]); return r })(a, n) }, utf8border: (t, e) => { (e = e || t.length) > t.length && (e = t.length); let r = e - 1; for (; r >= 0 && 128 == (192 & t[r]);)r--; return r < 0 || 0 === r ? e : r + Gt[t[r]] > e ? r : e } }, Xt = function () { this.input = null, this.next_in = 0, this.avail_in = 0, this.total_in = 0, this.output = null, this.next_out = 0, this.avail_out = 0, this.total_out = 0, this.msg = "", this.state = null, this.data_type = 2, this.adler = 0 }; const Vt = Object.prototype.toString, { Z_NO_FLUSH: qt, Z_SYNC_FLUSH: Jt, Z_FULL_FLUSH: Qt, Z_FINISH: te, Z_OK: ee, Z_STREAM_END: re, Z_DEFAULT_COMPRESSION: ie, Z_DEFAULT_STRATEGY: ne, Z_DEFLATED: ae } = $; function se(t) { this.options = Kt.assign({ level: ie, method: ae, chunkSize: 16384, windowBits: 15, memLevel: 8, strategy: ne }, t || {}); let e = this.options; e.raw && e.windowBits > 0 ? e.windowBits = -e.windowBits : e.gzip && e.windowBits > 0 && e.windowBits < 16 && (e.windowBits += 16), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Xt, this.strm.avail_out = 0; let r = jt.deflateInit2(this.strm, e.level, e.method, e.windowBits, e.memLevel, e.strategy); if (r !== ee) throw new Error(K[r]); if (e.header && jt.deflateSetHeader(this.strm, e.header), e.dictionary) { let t; if (t = "string" == typeof e.dictionary ? Yt.string2buf(e.dictionary) : "[object ArrayBuffer]" === Vt.call(e.dictionary) ? new Uint8Array(e.dictionary) : e.dictionary, r = jt.deflateSetDictionary(this.strm, t), r !== ee) throw new Error(K[r]); this._dict_set = !0 } } function oe(t, e) { const r = new se(e); if (r.push(t, !0), r.err) throw r.msg || K[r.err]; return r.result } se.prototype.push = function (t, e) { const r = this.strm, i = this.options.chunkSize; let n, a; if (this.ended) return !1; for (a = e === ~~e ? e : !0 === e ? te : qt, "string" == typeof t ? r.input = Yt.string2buf(t) : "[object ArrayBuffer]" === Vt.call(t) ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length; ;)if (0 === r.avail_out && (r.output = new Uint8Array(i), r.next_out = 0, r.avail_out = i), (a === Jt || a === Qt) && r.avail_out <= 6) this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0; else { if (n = jt.deflate(r, a), n === re) return r.next_out > 0 && this.onData(r.output.subarray(0, r.next_out)), n = jt.deflateEnd(this.strm), this.onEnd(n), this.ended = !0, n === ee; if (0 !== r.avail_out) { if (a > 0 && r.next_out > 0) this.onData(r.output.subarray(0, r.next_out)), r.avail_out = 0; else if (0 === r.avail_in) break } else this.onData(r.output) } return !0 }, se.prototype.onData = function (t) { this.chunks.push(t) }, se.prototype.onEnd = function (t) { t === ee && (this.result = Kt.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }; var he = { Deflate: se, deflate: oe, deflateRaw: function (t, e) { return (e = e || {}).raw = !0, oe(t, e) }, gzip: function (t, e) { return (e = e || {}).gzip = !0, oe(t, e) }, constants: $ }; const le = 16209; var de = function (t, e) { let r, i, n, a, s, o, h, l, d, f, c, u, _, p, w, g, b, m, y, v, k, E, x, A; const U = t.state; r = t.next_in, x = t.input, i = r + (t.avail_in - 5), n = t.next_out, A = t.output, a = n - (e - t.avail_out), s = n + (t.avail_out - 257), o = U.dmax, h = U.wsize, l = U.whave, d = U.wnext, f = U.window, c = U.hold, u = U.bits, _ = U.lencode, p = U.distcode, w = (1 << U.lenbits) - 1, g = (1 << U.distbits) - 1; t: do { u < 15 && (c += x[r++] << u, u += 8, c += x[r++] << u, u += 8), b = _[c & w]; e: for (; ;) { if (m = b >>> 24, c >>>= m, u -= m, m = b >>> 16 & 255, 0 === m) A[n++] = 65535 & b; else { if (!(16 & m)) { if (64 & m) { if (32 & m) { U.mode = 16191; break t } t.msg = "invalid literal/length code", U.mode = le; break t } b = _[(65535 & b) + (c & (1 << m) - 1)]; continue e } for (y = 65535 & b, m &= 15, m && (u < m && (c += x[r++] << u, u += 8), y += c & (1 << m) - 1, c >>>= m, u -= m), u < 15 && (c += x[r++] << u, u += 8, c += x[r++] << u, u += 8), b = p[c & g]; ;) { if (m = b >>> 24, c >>>= m, u -= m, m = b >>> 16 & 255, 16 & m) { if (v = 65535 & b, m &= 15, u < m && (c += x[r++] << u, u += 8, u < m && (c += x[r++] << u, u += 8)), v += c & (1 << m) - 1, v > o) { t.msg = "invalid distance too far back", U.mode = le; break t } if (c >>>= m, u -= m, m = n - a, v > m) { if (m = v - m, m > l && U.sane) { t.msg = "invalid distance too far back", U.mode = le; break t } if (k = 0, E = f, 0 === d) { if (k += h - m, m < y) { y -= m; do { A[n++] = f[k++] } while (--m); k = n - v, E = A } } else if (d < m) { if (k += h + d - m, m -= d, m < y) { y -= m; do { A[n++] = f[k++] } while (--m); if (k = 0, d < y) { m = d, y -= m; do { A[n++] = f[k++] } while (--m); k = n - v, E = A } } } else if (k += d - m, m < y) { y -= m; do { A[n++] = f[k++] } while (--m); k = n - v, E = A } for (; y > 2;)A[n++] = E[k++], A[n++] = E[k++], A[n++] = E[k++], y -= 3; y && (A[n++] = E[k++], y > 1 && (A[n++] = E[k++])) } else { k = n - v; do { A[n++] = A[k++], A[n++] = A[k++], A[n++] = A[k++], y -= 3 } while (y > 2); y && (A[n++] = A[k++], y > 1 && (A[n++] = A[k++])) } break } if (64 & m) { t.msg = "invalid distance code", U.mode = le; break t } b = p[(65535 & b) + (c & (1 << m) - 1)] } } break } } while (r < i && n < s); y = u >> 3, r -= y, u -= y << 3, c &= (1 << u) - 1, t.next_in = r, t.next_out = n, t.avail_in = r < i ? i - r + 5 : 5 - (r - i), t.avail_out = n < s ? s - n + 257 : 257 - (n - s), U.hold = c, U.bits = u }; const fe = new Uint16Array([3, 4, 5, 6, 7, 8, 9, 10, 11, 13, 15, 17, 19, 23, 27, 31, 35, 43, 51, 59, 67, 83, 99, 115, 131, 163, 195, 227, 258, 0, 0]), ce = new Uint8Array([16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 18, 18, 18, 18, 19, 19, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 16, 72, 78]), ue = new Uint16Array([1, 2, 3, 4, 5, 7, 9, 13, 17, 25, 33, 49, 65, 97, 129, 193, 257, 385, 513, 769, 1025, 1537, 2049, 3073, 4097, 6145, 8193, 12289, 16385, 24577, 0, 0]), _e = new Uint8Array([16, 16, 16, 16, 17, 17, 18, 18, 19, 19, 20, 20, 21, 21, 22, 22, 23, 23, 24, 24, 25, 25, 26, 26, 27, 27, 28, 28, 29, 29, 64, 64]); var pe = (t, e, r, i, n, a, s, o) => { const h = o.bits; let l, d, f, c, u, _, p = 0, w = 0, g = 0, b = 0, m = 0, y = 0, v = 0, k = 0, E = 0, x = 0, A = null; const U = new Uint16Array(16), z = new Uint16Array(16); let R, L, T, O = null; for (p = 0; p <= 15; p++)U[p] = 0; for (w = 0; w < i; w++)U[e[r + w]]++; for (m = h, b = 15; b >= 1 && 0 === U[b]; b--); if (m > b && (m = b), 0 === b) return n[a++] = 20971520, n[a++] = 20971520, o.bits = 1, 0; for (g = 1; g < b && 0 === U[g]; g++); for (m < g && (m = g), k = 1, p = 1; p <= 15; p++)if (k <<= 1, k -= U[p], k < 0) return -1; if (k > 0 && (0 === t || 1 !== b)) return -1; for (z[1] = 0, p = 1; p < 15; p++)z[p + 1] = z[p] + U[p]; for (w = 0; w < i; w++)0 !== e[r + w] && (s[z[e[r + w]]++] = w); if (0 === t ? (A = O = s, _ = 20) : 1 === t ? (A = fe, O = ce, _ = 257) : (A = ue, O = _e, _ = 0), x = 0, w = 0, p = g, u = a, y = m, v = 0, f = -1, E = 1 << m, c = E - 1, 1 === t && E > 852 || 2 === t && E > 592) return 1; for (; ;) { R = p - v, s[w] + 1 < _ ? (L = 0, T = s[w]) : s[w] >= _ ? (L = O[s[w] - _], T = A[s[w] - _]) : (L = 96, T = 0), l = 1 << p - v, d = 1 << y, g = d; do { d -= l, n[u + (x >> v) + d] = R << 24 | L << 16 | T } while (0 !== d); for (l = 1 << p - 1; x & l;)l >>= 1; if (0 !== l ? (x &= l - 1, x += l) : x = 0, w++, 0 == --U[p]) { if (p === b) break; p = e[r + s[w]] } if (p > m && (x & c) !== f) { for (0 === v && (v = m), u += g, y = p - v, k = 1 << y; y + v < b && (k -= U[y + v], !(k <= 0));)y++, k <<= 1; if (E += 1 << y, 1 === t && E > 852 || 2 === t && E > 592) return 1; f = x & c, n[f] = m << 24 | y << 16 | u - a } } return 0 !== x && (n[u + x] = p - v << 24 | 64 << 16), o.bits = m, 0 }; const { Z_FINISH: we, Z_BLOCK: ge, Z_TREES: be, Z_OK: me, Z_STREAM_END: ye, Z_NEED_DICT: ve, Z_STREAM_ERROR: ke, Z_DATA_ERROR: Ee, Z_MEM_ERROR: xe, Z_BUF_ERROR: Ae, Z_DEFLATED: Ue } = $, ze = 16180, Re = 16190, Le = 16191, Te = 16192, Oe = 16194, Ne = 16199, Se = 16200, De = 16206, Ie = 16209, Be = t => (t >>> 24 & 255) + (t >>> 8 & 65280) + ((65280 & t) << 8) + ((255 & t) << 24); function Ce() { this.strm = null, this.mode = 0, this.last = !1, this.wrap = 0, this.havedict = !1, this.flags = 0, this.dmax = 0, this.check = 0, this.total = 0, this.head = null, this.wbits = 0, this.wsize = 0, this.whave = 0, this.wnext = 0, this.window = null, this.hold = 0, this.bits = 0, this.length = 0, this.offset = 0, this.extra = 0, this.lencode = null, this.distcode = null, this.lenbits = 0, this.distbits = 0, this.ncode = 0, this.nlen = 0, this.ndist = 0, this.have = 0, this.next = null, this.lens = new Uint16Array(320), this.work = new Uint16Array(288), this.lendyn = null, this.distdyn = null, this.sane = 0, this.back = 0, this.was = 0 } const Ze = t => { if (!t) return 1; const e = t.state; return !e || e.strm !== t || e.mode < ze || e.mode > 16211 ? 1 : 0 }, Fe = t => { if (Ze(t)) return ke; const e = t.state; return t.total_in = t.total_out = e.total = 0, t.msg = "", e.wrap && (t.adler = 1 & e.wrap), e.mode = ze, e.last = 0, e.havedict = 0, e.flags = -1, e.dmax = 32768, e.head = null, e.hold = 0, e.bits = 0, e.lencode = e.lendyn = new Int32Array(852), e.distcode = e.distdyn = new Int32Array(592), e.sane = 1, e.back = -1, me }, Pe = t => { if (Ze(t)) return ke; const e = t.state; return e.wsize = 0, e.whave = 0, e.wnext = 0, Fe(t) }, Me = (t, e) => { let r; if (Ze(t)) return ke; const i = t.state; return e < 0 ? (r = 0, e = -e) : (r = 5 + (e >> 4), e < 48 && (e &= 15)), e && (e < 8 || e > 15) ? ke : (null !== i.window && i.wbits !== e && (i.window = null), i.wrap = r, i.wbits = e, Pe(t)) }, He = (t, e) => { if (!t) return ke; const r = new Ce; t.state = r, r.strm = t, r.window = null, r.mode = ze; const i = Me(t, e); return i !== me && (t.state = null), i }; let je, We, Ke = !0; const $e = t => { if (Ke) { je = new Int32Array(512), We = new Int32Array(32); let e = 0; for (; e < 144;)t.lens[e++] = 8; for (; e < 256;)t.lens[e++] = 9; for (; e < 280;)t.lens[e++] = 7; for (; e < 288;)t.lens[e++] = 8; for (pe(1, t.lens, 0, 288, je, 0, t.work, { bits: 9 }), e = 0; e < 32;)t.lens[e++] = 5; pe(2, t.lens, 0, 32, We, 0, t.work, { bits: 5 }), Ke = !1 } t.lencode = je, t.lenbits = 9, t.distcode = We, t.distbits = 5 }, Ge = (t, e, r, i) => { let n; const a = t.state; return null === a.window && (a.wsize = 1 << a.wbits, a.wnext = 0, a.whave = 0, a.window = new Uint8Array(a.wsize)), i >= a.wsize ? (a.window.set(e.subarray(r - a.wsize, r), 0), a.wnext = 0, a.whave = a.wsize) : (n = a.wsize - a.wnext, n > i && (n = i), a.window.set(e.subarray(r - i, r - i + n), a.wnext), (i -= n) ? (a.window.set(e.subarray(r - i, r), 0), a.wnext = i, a.whave = a.wsize) : (a.wnext += n, a.wnext === a.wsize && (a.wnext = 0), a.whave < a.wsize && (a.whave += n))), 0 }; var Ye = { inflateReset: Pe, inflateReset2: Me, inflateResetKeep: Fe, inflateInit: t => He(t, 15), inflateInit2: He, inflate: (t, e) => { let r, i, n, a, s, o, h, l, d, f, c, u, _, p, w, g, b, m, y, v, k, E, x = 0; const A = new Uint8Array(4); let U, z; const R = new Uint8Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]); if (Ze(t) || !t.output || !t.input && 0 !== t.avail_in) return ke; r = t.state, r.mode === Le && (r.mode = Te), s = t.next_out, n = t.output, h = t.avail_out, a = t.next_in, i = t.input, o = t.avail_in, l = r.hold, d = r.bits, f = o, c = h, E = me; t: for (; ;)switch (r.mode) { case ze: if (0 === r.wrap) { r.mode = Te; break } for (; d < 16;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } if (2 & r.wrap && 35615 === l) { 0 === r.wbits && (r.wbits = 15), r.check = 0, A[0] = 255 & l, A[1] = l >>> 8 & 255, r.check = W(r.check, A, 2, 0), l = 0, d = 0, r.mode = 16181; break } if (r.head && (r.head.done = !1), !(1 & r.wrap) || (((255 & l) << 8) + (l >> 8)) % 31) { t.msg = "incorrect header check", r.mode = Ie; break } if ((15 & l) !== Ue) { t.msg = "unknown compression method", r.mode = Ie; break } if (l >>>= 4, d -= 4, k = 8 + (15 & l), 0 === r.wbits && (r.wbits = k), k > 15 || k > r.wbits) { t.msg = "invalid window size", r.mode = Ie; break } r.dmax = 1 << r.wbits, r.flags = 0, t.adler = r.check = 1, r.mode = 512 & l ? 16189 : Le, l = 0, d = 0; break; case 16181: for (; d < 16;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } if (r.flags = l, (255 & r.flags) !== Ue) { t.msg = "unknown compression method", r.mode = Ie; break } if (57344 & r.flags) { t.msg = "unknown header flags set", r.mode = Ie; break } r.head && (r.head.text = l >> 8 & 1), 512 & r.flags && 4 & r.wrap && (A[0] = 255 & l, A[1] = l >>> 8 & 255, r.check = W(r.check, A, 2, 0)), l = 0, d = 0, r.mode = 16182; case 16182: for (; d < 32;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } r.head && (r.head.time = l), 512 & r.flags && 4 & r.wrap && (A[0] = 255 & l, A[1] = l >>> 8 & 255, A[2] = l >>> 16 & 255, A[3] = l >>> 24 & 255, r.check = W(r.check, A, 4, 0)), l = 0, d = 0, r.mode = 16183; case 16183: for (; d < 16;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } r.head && (r.head.xflags = 255 & l, r.head.os = l >> 8), 512 & r.flags && 4 & r.wrap && (A[0] = 255 & l, A[1] = l >>> 8 & 255, r.check = W(r.check, A, 2, 0)), l = 0, d = 0, r.mode = 16184; case 16184: if (1024 & r.flags) { for (; d < 16;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } r.length = l, r.head && (r.head.extra_len = l), 512 & r.flags && 4 & r.wrap && (A[0] = 255 & l, A[1] = l >>> 8 & 255, r.check = W(r.check, A, 2, 0)), l = 0, d = 0 } else r.head && (r.head.extra = null); r.mode = 16185; case 16185: if (1024 & r.flags && (u = r.length, u > o && (u = o), u && (r.head && (k = r.head.extra_len - r.length, r.head.extra || (r.head.extra = new Uint8Array(r.head.extra_len)), r.head.extra.set(i.subarray(a, a + u), k)), 512 & r.flags && 4 & r.wrap && (r.check = W(r.check, i, u, a)), o -= u, a += u, r.length -= u), r.length)) break t; r.length = 0, r.mode = 16186; case 16186: if (2048 & r.flags) { if (0 === o) break t; u = 0; do { k = i[a + u++], r.head && k && r.length < 65536 && (r.head.name += String.fromCharCode(k)) } while (k && u < o); if (512 & r.flags && 4 & r.wrap && (r.check = W(r.check, i, u, a)), o -= u, a += u, k) break t } else r.head && (r.head.name = null); r.length = 0, r.mode = 16187; case 16187: if (4096 & r.flags) { if (0 === o) break t; u = 0; do { k = i[a + u++], r.head && k && r.length < 65536 && (r.head.comment += String.fromCharCode(k)) } while (k && u < o); if (512 & r.flags && 4 & r.wrap && (r.check = W(r.check, i, u, a)), o -= u, a += u, k) break t } else r.head && (r.head.comment = null); r.mode = 16188; case 16188: if (512 & r.flags) { for (; d < 16;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } if (4 & r.wrap && l !== (65535 & r.check)) { t.msg = "header crc mismatch", r.mode = Ie; break } l = 0, d = 0 } r.head && (r.head.hcrc = r.flags >> 9 & 1, r.head.done = !0), t.adler = r.check = 0, r.mode = Le; break; case 16189: for (; d < 32;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } t.adler = r.check = Be(l), l = 0, d = 0, r.mode = Re; case Re: if (0 === r.havedict) return t.next_out = s, t.avail_out = h, t.next_in = a, t.avail_in = o, r.hold = l, r.bits = d, ve; t.adler = r.check = 1, r.mode = Le; case Le: if (e === ge || e === be) break t; case Te: if (r.last) { l >>>= 7 & d, d -= 7 & d, r.mode = De; break } for (; d < 3;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } switch (r.last = 1 & l, l >>>= 1, d -= 1, 3 & l) { case 0: r.mode = 16193; break; case 1: if ($e(r), r.mode = Ne, e === be) { l >>>= 2, d -= 2; break t } break; case 2: r.mode = 16196; break; case 3: t.msg = "invalid block type", r.mode = Ie }l >>>= 2, d -= 2; break; case 16193: for (l >>>= 7 & d, d -= 7 & d; d < 32;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } if ((65535 & l) != (l >>> 16 ^ 65535)) { t.msg = "invalid stored block lengths", r.mode = Ie; break } if (r.length = 65535 & l, l = 0, d = 0, r.mode = Oe, e === be) break t; case Oe: r.mode = 16195; case 16195: if (u = r.length, u) { if (u > o && (u = o), u > h && (u = h), 0 === u) break t; n.set(i.subarray(a, a + u), s), o -= u, a += u, h -= u, s += u, r.length -= u; break } r.mode = Le; break; case 16196: for (; d < 14;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } if (r.nlen = 257 + (31 & l), l >>>= 5, d -= 5, r.ndist = 1 + (31 & l), l >>>= 5, d -= 5, r.ncode = 4 + (15 & l), l >>>= 4, d -= 4, r.nlen > 286 || r.ndist > 30) { t.msg = "too many length or distance symbols", r.mode = Ie; break } r.have = 0, r.mode = 16197; case 16197: for (; r.have < r.ncode;) { for (; d < 3;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } r.lens[R[r.have++]] = 7 & l, l >>>= 3, d -= 3 } for (; r.have < 19;)r.lens[R[r.have++]] = 0; if (r.lencode = r.lendyn, r.lenbits = 7, U = { bits: r.lenbits }, E = pe(0, r.lens, 0, 19, r.lencode, 0, r.work, U), r.lenbits = U.bits, E) { t.msg = "invalid code lengths set", r.mode = Ie; break } r.have = 0, r.mode = 16198; case 16198: for (; r.have < r.nlen + r.ndist;) { for (; x = r.lencode[l & (1 << r.lenbits) - 1], w = x >>> 24, g = x >>> 16 & 255, b = 65535 & x, !(w <= d);) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } if (b < 16) l >>>= w, d -= w, r.lens[r.have++] = b; else { if (16 === b) { for (z = w + 2; d < z;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } if (l >>>= w, d -= w, 0 === r.have) { t.msg = "invalid bit length repeat", r.mode = Ie; break } k = r.lens[r.have - 1], u = 3 + (3 & l), l >>>= 2, d -= 2 } else if (17 === b) { for (z = w + 3; d < z;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } l >>>= w, d -= w, k = 0, u = 3 + (7 & l), l >>>= 3, d -= 3 } else { for (z = w + 7; d < z;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } l >>>= w, d -= w, k = 0, u = 11 + (127 & l), l >>>= 7, d -= 7 } if (r.have + u > r.nlen + r.ndist) { t.msg = "invalid bit length repeat", r.mode = Ie; break } for (; u--;)r.lens[r.have++] = k } } if (r.mode === Ie) break; if (0 === r.lens[256]) { t.msg = "invalid code -- missing end-of-block", r.mode = Ie; break } if (r.lenbits = 9, U = { bits: r.lenbits }, E = pe(1, r.lens, 0, r.nlen, r.lencode, 0, r.work, U), r.lenbits = U.bits, E) { t.msg = "invalid literal/lengths set", r.mode = Ie; break } if (r.distbits = 6, r.distcode = r.distdyn, U = { bits: r.distbits }, E = pe(2, r.lens, r.nlen, r.ndist, r.distcode, 0, r.work, U), r.distbits = U.bits, E) { t.msg = "invalid distances set", r.mode = Ie; break } if (r.mode = Ne, e === be) break t; case Ne: r.mode = Se; case Se: if (o >= 6 && h >= 258) { t.next_out = s, t.avail_out = h, t.next_in = a, t.avail_in = o, r.hold = l, r.bits = d, de(t, c), s = t.next_out, n = t.output, h = t.avail_out, a = t.next_in, i = t.input, o = t.avail_in, l = r.hold, d = r.bits, r.mode === Le && (r.back = -1); break } for (r.back = 0; x = r.lencode[l & (1 << r.lenbits) - 1], w = x >>> 24, g = x >>> 16 & 255, b = 65535 & x, !(w <= d);) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } if (g && !(240 & g)) { for (m = w, y = g, v = b; x = r.lencode[v + ((l & (1 << m + y) - 1) >> m)], w = x >>> 24, g = x >>> 16 & 255, b = 65535 & x, !(m + w <= d);) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } l >>>= m, d -= m, r.back += m } if (l >>>= w, d -= w, r.back += w, r.length = b, 0 === g) { r.mode = 16205; break } if (32 & g) { r.back = -1, r.mode = Le; break } if (64 & g) { t.msg = "invalid literal/length code", r.mode = Ie; break } r.extra = 15 & g, r.mode = 16201; case 16201: if (r.extra) { for (z = r.extra; d < z;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } r.length += l & (1 << r.extra) - 1, l >>>= r.extra, d -= r.extra, r.back += r.extra } r.was = r.length, r.mode = 16202; case 16202: for (; x = r.distcode[l & (1 << r.distbits) - 1], w = x >>> 24, g = x >>> 16 & 255, b = 65535 & x, !(w <= d);) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } if (!(240 & g)) { for (m = w, y = g, v = b; x = r.distcode[v + ((l & (1 << m + y) - 1) >> m)], w = x >>> 24, g = x >>> 16 & 255, b = 65535 & x, !(m + w <= d);) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } l >>>= m, d -= m, r.back += m } if (l >>>= w, d -= w, r.back += w, 64 & g) { t.msg = "invalid distance code", r.mode = Ie; break } r.offset = b, r.extra = 15 & g, r.mode = 16203; case 16203: if (r.extra) { for (z = r.extra; d < z;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } r.offset += l & (1 << r.extra) - 1, l >>>= r.extra, d -= r.extra, r.back += r.extra } if (r.offset > r.dmax) { t.msg = "invalid distance too far back", r.mode = Ie; break } r.mode = 16204; case 16204: if (0 === h) break t; if (u = c - h, r.offset > u) { if (u = r.offset - u, u > r.whave && r.sane) { t.msg = "invalid distance too far back", r.mode = Ie; break } u > r.wnext ? (u -= r.wnext, _ = r.wsize - u) : _ = r.wnext - u, u > r.length && (u = r.length), p = r.window } else p = n, _ = s - r.offset, u = r.length; u > h && (u = h), h -= u, r.length -= u; do { n[s++] = p[_++] } while (--u); 0 === r.length && (r.mode = Se); break; case 16205: if (0 === h) break t; n[s++] = r.length, h--, r.mode = Se; break; case De: if (r.wrap) { for (; d < 32;) { if (0 === o) break t; o--, l |= i[a++] << d, d += 8 } if (c -= h, t.total_out += c, r.total += c, 4 & r.wrap && c && (t.adler = r.check = r.flags ? W(r.check, n, c, s - c) : H(r.check, n, c, s - c)), c = h, 4 & r.wrap && (r.flags ? l : Be(l)) !== r.check) { t.msg = "incorrect data check", r.mode = Ie; break } l = 0, d = 0 } r.mode = 16207; case 16207: if (r.wrap && r.flags) { for (; d < 32;) { if (0 === o) break t; o--, l += i[a++] << d, d += 8 } if (4 & r.wrap && l !== (4294967295 & r.total)) { t.msg = "incorrect length check", r.mode = Ie; break } l = 0, d = 0 } r.mode = 16208; case 16208: E = ye; break t; case Ie: E = Ee; break t; case 16210: return xe; default: return ke }return t.next_out = s, t.avail_out = h, t.next_in = a, t.avail_in = o, r.hold = l, r.bits = d, (r.wsize || c !== t.avail_out && r.mode < Ie && (r.mode < De || e !== we)) && Ge(t, t.output, t.next_out, c - t.avail_out), f -= t.avail_in, c -= t.avail_out, t.total_in += f, t.total_out += c, r.total += c, 4 & r.wrap && c && (t.adler = r.check = r.flags ? W(r.check, n, c, t.next_out - c) : H(r.check, n, c, t.next_out - c)), t.data_type = r.bits + (r.last ? 64 : 0) + (r.mode === Le ? 128 : 0) + (r.mode === Ne || r.mode === Oe ? 256 : 0), (0 === f && 0 === c || e === we) && E === me && (E = Ae), E }, inflateEnd: t => { if (Ze(t)) return ke; let e = t.state; return e.window && (e.window = null), t.state = null, me }, inflateGetHeader: (t, e) => { if (Ze(t)) return ke; const r = t.state; return 2 & r.wrap ? (r.head = e, e.done = !1, me) : ke }, inflateSetDictionary: (t, e) => { const r = e.length; let i, n, a; return Ze(t) ? ke : (i = t.state, 0 !== i.wrap && i.mode !== Re ? ke : i.mode === Re && (n = 1, n = H(n, e, r, 0), n !== i.check) ? Ee : (a = Ge(t, e, r, r), a ? (i.mode = 16210, xe) : (i.havedict = 1, me))) }, inflateInfo: "pako inflate (from Nodeca project)" }, Xe = function () { this.text = 0, this.time = 0, this.xflags = 0, this.os = 0, this.extra = null, this.extra_len = 0, this.name = "", this.comment = "", this.hcrc = 0, this.done = !1 }; const Ve = Object.prototype.toString, { Z_NO_FLUSH: qe, Z_FINISH: Je, Z_OK: Qe, Z_STREAM_END: tr, Z_NEED_DICT: er, Z_STREAM_ERROR: rr, Z_DATA_ERROR: ir, Z_MEM_ERROR: nr } = $; function ar(t) { this.options = Kt.assign({ chunkSize: 65536, windowBits: 15, to: "" }, t || {}); const e = this.options; e.raw && e.windowBits >= 0 && e.windowBits < 16 && (e.windowBits = -e.windowBits, 0 === e.windowBits && (e.windowBits = -15)), !(e.windowBits >= 0 && e.windowBits < 16) || t && t.windowBits || (e.windowBits += 32), e.windowBits > 15 && e.windowBits < 48 && (15 & e.windowBits || (e.windowBits |= 15)), this.err = 0, this.msg = "", this.ended = !1, this.chunks = [], this.strm = new Xt, this.strm.avail_out = 0; let r = Ye.inflateInit2(this.strm, e.windowBits); if (r !== Qe) throw new Error(K[r]); if (this.header = new Xe, Ye.inflateGetHeader(this.strm, this.header), e.dictionary && ("string" == typeof e.dictionary ? e.dictionary = Yt.string2buf(e.dictionary) : "[object ArrayBuffer]" === Ve.call(e.dictionary) && (e.dictionary = new Uint8Array(e.dictionary)), e.raw && (r = Ye.inflateSetDictionary(this.strm, e.dictionary), r !== Qe))) throw new Error(K[r]) } function sr(t, e) { const r = new ar(e); if (r.push(t), r.err) throw r.msg || K[r.err]; return r.result } ar.prototype.push = function (t, e) { const r = this.strm, i = this.options.chunkSize, n = this.options.dictionary; let a, s, o; if (this.ended) return !1; for (s = e === ~~e ? e : !0 === e ? Je : qe, "[object ArrayBuffer]" === Ve.call(t) ? r.input = new Uint8Array(t) : r.input = t, r.next_in = 0, r.avail_in = r.input.length; ;) { for (0 === r.avail_out && (r.output = new Uint8Array(i), r.next_out = 0, r.avail_out = i), a = Ye.inflate(r, s), a === er && n && (a = Ye.inflateSetDictionary(r, n), a === Qe ? a = Ye.inflate(r, s) : a === ir && (a = er)); r.avail_in > 0 && a === tr && r.state.wrap > 0 && 0 !== t[r.next_in];)Ye.inflateReset(r), a = Ye.inflate(r, s); switch (a) { case rr: case ir: case er: case nr: return this.onEnd(a), this.ended = !0, !1 }if (o = r.avail_out, r.next_out && (0 === r.avail_out || a === tr)) if ("string" === this.options.to) { let t = Yt.utf8border(r.output, r.next_out), e = r.next_out - t, n = Yt.buf2string(r.output, t); r.next_out = e, r.avail_out = i - e, e && r.output.set(r.output.subarray(t, t + e), 0), this.onData(n) } else this.onData(r.output.length === r.next_out ? r.output : r.output.subarray(0, r.next_out)); if (a !== Qe || 0 !== o) { if (a === tr) return a = Ye.inflateEnd(this.strm), this.onEnd(a), this.ended = !0, !0; if (0 === r.avail_in) break } } return !0 }, ar.prototype.onData = function (t) { this.chunks.push(t) }, ar.prototype.onEnd = function (t) { t === Qe && ("string" === this.options.to ? this.result = this.chunks.join("") : this.result = Kt.flattenChunks(this.chunks)), this.chunks = [], this.err = t, this.msg = this.strm.msg }; var or = { Inflate: ar, inflate: sr, inflateRaw: function (t, e) { return (e = e || {}).raw = !0, sr(t, e) }, ungzip: sr, constants: $ }; const { Deflate: hr, deflate: lr, deflateRaw: dr, gzip: fr } = he, { Inflate: cr, inflate: ur, inflateRaw: _r, ungzip: pr } = or; var wr = lr, gr = cr, br = ur; const mr = [137, 80, 78, 71, 13, 10, 26, 10], yr = []; for (let t = 0; t < 256; t++) { let e = t; for (let t = 0; t < 8; t++)1 & e ? e = 3988292384 ^ e >>> 1 : e >>>= 1; yr[t] = e } const vr = 4294967295; function kr(t, e) { return (function (t, e, r) { let i = t; for (let t = 0; t < r; t++)i = yr[255 & (i ^ e[t])] ^ i >>> 8; return i }(vr, t, e) ^ vr) >>> 0 } var Er, xr, Ar, Ur; !function (t) { t[t.UNKNOWN = -1] = "UNKNOWN", t[t.GREYSCALE = 0] = "GREYSCALE", t[t.TRUECOLOUR = 2] = "TRUECOLOUR", t[t.INDEXED_COLOUR = 3] = "INDEXED_COLOUR", t[t.GREYSCALE_ALPHA = 4] = "GREYSCALE_ALPHA", t[t.TRUECOLOUR_ALPHA = 6] = "TRUECOLOUR_ALPHA" }(Er || (Er = {})), function (t) { t[t.UNKNOWN = -1] = "UNKNOWN", t[t.DEFLATE = 0] = "DEFLATE" }(xr || (xr = {})), function (t) { t[t.UNKNOWN = -1] = "UNKNOWN", t[t.ADAPTIVE = 0] = "ADAPTIVE" }(Ar || (Ar = {})), function (t) { t[t.UNKNOWN = -1] = "UNKNOWN", t[t.NO_INTERLACE = 0] = "NO_INTERLACE", t[t.ADAM7 = 1] = "ADAM7" }(Ur || (Ur = {})); const zr = new Uint8Array(0), Rr = new Uint16Array([255]), Lr = 255 === new Uint8Array(Rr.buffer)[0]; class Tr extends h { constructor(t, e = {}) { super(t); const { checkCrc: r = !1 } = e; this._checkCrc = r, this._inflator = new gr, this._png = { width: -1, height: -1, channels: -1, data: new Uint8Array(0), depth: 1, text: {} }, this._end = !1, this._hasPalette = !1, this._palette = [], this._hasTransparency = !1, this._transparency = new Uint16Array(0), this._compressionMethod = xr.UNKNOWN, this._filterMethod = Ar.UNKNOWN, this._interlaceMethod = Ur.UNKNOWN, this._colorType = Er.UNKNOWN, this.setBigEndian() } decode() { for (this.decodeSignature(); !this._end;)this.decodeChunk(); return this.decodeImage(), this._png } decodeSignature() { for (let t = 0; t < mr.length; t++)if (this.readUint8() !== mr[t]) throw new Error(`wrong PNG signature. Byte at ${t} should be ${mr[t]}.`) } decodeChunk() { const t = this.readUint32(), e = this.readChars(4), r = this.offset; switch (e) { case "IHDR": this.decodeIHDR(); break; case "PLTE": this.decodePLTE(t); break; case "IDAT": this.decodeIDAT(t); break; case "IEND": this._end = !0; break; case "tRNS": this.decodetRNS(t); break; case "iCCP": this.decodeiCCP(t); break; case "tEXt": this.decodetEXt(t); break; case "pHYs": this.decodepHYs(); break; default: this.skip(t) }if (this.offset - r !== t) throw new Error(`Length mismatch while decoding chunk ${e}`); if (this._checkCrc) { const r = this.readUint32(), i = t + 4, n = kr(new Uint8Array(this.buffer, this.byteOffset + this.offset - i - 4, i), i); if (n !== r) throw new Error(`CRC mismatch for chunk ${e}. Expected ${r}, found ${n}`) } else this.skip(4) } decodeIHDR() { const t = this._png; t.width = this.readUint32(), t.height = this.readUint32(), t.depth = function (t) { if (1 !== t && 2 !== t && 4 !== t && 8 !== t && 16 !== t) throw new Error(`invalid bit depth: ${t}`); return t }(this.readUint8()); const e = this.readUint8(); let r; switch (this._colorType = e, e) { case Er.GREYSCALE: r = 1; break; case Er.TRUECOLOUR: r = 3; break; case Er.INDEXED_COLOUR: r = 1; break; case Er.GREYSCALE_ALPHA: r = 2; break; case Er.TRUECOLOUR_ALPHA: r = 4; break; default: throw new Error(`Unknown color type: ${e}`) }if (this._png.channels = r, this._compressionMethod = this.readUint8(), this._compressionMethod !== xr.DEFLATE) throw new Error(`Unsupported compression method: ${this._compressionMethod}`); this._filterMethod = this.readUint8(), this._interlaceMethod = this.readUint8() } decodePLTE(t) { if (t % 3 != 0) throw new RangeError(`PLTE field length must be a multiple of 3. Got ${t}`); const e = t / 3; this._hasPalette = !0; const r = []; this._palette = r; for (let t = 0; t < e; t++)r.push([this.readUint8(), this.readUint8(), this.readUint8()]) } decodeIDAT(t) { this._inflator.push(new Uint8Array(this.buffer, this.offset + this.byteOffset, t)), this.skip(t) } decodetRNS(t) { switch (this._colorType) { case Er.GREYSCALE: case Er.TRUECOLOUR: if (t % 2 != 0) throw new RangeError(`tRNS chunk length must be a multiple of 2. Got ${t}`); if (t / 2 > this._png.width * this._png.height) throw new Error(`tRNS chunk contains more alpha values than there are pixels (${t / 2} vs ${this._png.width * this._png.height})`); this._hasTransparency = !0, this._transparency = new Uint16Array(t / 2); for (let e = 0; e < t / 2; e++)this._transparency[e] = this.readUint16(); break; case Er.INDEXED_COLOUR: { if (t > this._palette.length) throw new Error(`tRNS chunk contains more alpha values than there are palette colors (${t} vs ${this._palette.length})`); let e = 0; for (; e < t; e++) { const t = this.readByte(); this._palette[e].push(t) } for (; e < this._palette.length; e++)this._palette[e].push(255); break } default: throw new Error(`tRNS chunk is not supported for color type ${this._colorType}`) } } decodeiCCP(t) { let e, r = ""; for (; "\0" !== (e = this.readChar());)r += e; const i = this.readUint8(); if (i !== xr.DEFLATE) throw new Error(`Unsupported iCCP compression method: ${i}`); const n = this.readBytes(t - r.length - 2); this._png.iccEmbeddedProfile = { name: r, profile: br(n) } } decodetEXt(t) { let e, r = ""; for (; "\0" !== (e = this.readChar());)r += e; this._png.text[r] = this.readChars(t - r.length - 1) } decodepHYs() { const t = this.readUint32(), e = this.readUint32(), r = this.readByte(); this._png.resolution = { x: t, y: e, unit: r } } decodeImage() { if (this._inflator.err) throw new Error(`Error while decompressing the data: ${this._inflator.err}`); const t = this._inflator.result; if (this._filterMethod !== Ar.ADAPTIVE) throw new Error(`Filter method ${this._filterMethod} not supported`); if (this._interlaceMethod !== Ur.NO_INTERLACE) throw new Error(`Interlace method ${this._interlaceMethod} not supported`); this.decodeInterlaceNull(t) } decodeInterlaceNull(t) { const e = this._png.height, r = this._png.channels * this._png.depth / 8, i = this._png.width * r, n = new Uint8Array(this._png.height * i); let a, s, o = zr, h = 0; for (let l = 0; l < e; l++) { switch (a = t.subarray(h + 1, h + 1 + i), s = n.subarray(l * i, (l + 1) * i), t[h]) { case 0: Or(a, s, i); break; case 1: Nr(a, s, i, r); break; case 2: Sr(a, s, o, i); break; case 3: Dr(a, s, o, i, r); break; case 4: Ir(a, s, o, i, r); break; default: throw new Error(`Unsupported filter: ${t[h]}`) }o = s, h += i + 1 } if (this._hasPalette && (this._png.palette = this._palette), this._hasTransparency && (this._png.transparency = this._transparency), 16 === this._png.depth) { const t = new Uint16Array(n.buffer); if (Lr) for (let e = 0; e < t.length; e++)t[e] = (255 & (l = t[e])) << 8 | l >> 8 & 255; this._png.data = t } else this._png.data = n; var l } } function Or(t, e, r) { for (let i = 0; i < r; i++)e[i] = t[i] } function Nr(t, e, r, i) { let n = 0; for (; n < i; n++)e[n] = t[n]; for (; n < r; n++)e[n] = t[n] + e[n - i] & 255 } function Sr(t, e, r, i) { let n = 0; if (0 === r.length) for (; n < i; n++)e[n] = t[n]; else for (; n < i; n++)e[n] = t[n] + r[n] & 255 } function Dr(t, e, r, i, n) { let a = 0; if (0 === r.length) { for (; a < n; a++)e[a] = t[a]; for (; a < i; a++)e[a] = t[a] + (e[a - n] >> 1) & 255 } else { for (; a < n; a++)e[a] = t[a] + (r[a] >> 1) & 255; for (; a < i; a++)e[a] = t[a] + (e[a - n] + r[a] >> 1) & 255 } } function Ir(t, e, r, i, n) { let a = 0; if (0 === r.length) { for (; a < n; a++)e[a] = t[a]; for (; a < i; a++)e[a] = t[a] + e[a - n] & 255 } else { for (; a < n; a++)e[a] = t[a] + r[a] & 255; for (; a < i; a++)e[a] = t[a] + Br(e[a - n], r[a], r[a - n]) & 255 } } function Br(t, e, r) { const i = t + e - r, n = Math.abs(i - t), a = Math.abs(i - e), s = Math.abs(i - r); return n <= a && n <= s ? t : a <= s ? e : r } const Cr = { level: 3 }; class Zr extends h { constructor(t, e = {}) { super(), this._colorType = Er.UNKNOWN, this._zlibOptions = { ...Cr, ...e.zlib }, this._png = this._checkData(t), this.setBigEndian() } encode() { return this.encodeSignature(), this.encodeIHDR(), this.encodeData(), this.encodeIEND(), this.toArray() } encodeSignature() { this.writeBytes(mr) } encodeIHDR() { this.writeUint32(13), this.writeChars("IHDR"), this.writeUint32(this._png.width), this.writeUint32(this._png.height), this.writeByte(this._png.depth), this.writeByte(this._colorType), this.writeByte(xr.DEFLATE), this.writeByte(Ar.ADAPTIVE), this.writeByte(Ur.NO_INTERLACE), this.writeCrc(17) } encodeIEND() { this.writeUint32(0), this.writeChars("IEND"), this.writeCrc(4) } encodeIDAT(t) { this.writeUint32(t.length), this.writeChars("IDAT"), this.writeBytes(t), this.writeCrc(t.length + 4) } encodeData() { const { width: t, height: e, channels: r, depth: i, data: n } = this._png, a = r * t, s = (new h).setBigEndian(); let o = 0; for (let t = 0; t < e; t++)if (s.writeByte(0), 8 === i) o = Pr(n, s, a, o); else { if (16 !== i) throw new Error("unreachable"); o = Mr(n, s, a, o) } const l = s.toArray(), d = wr(l, this._zlibOptions); this.encodeIDAT(d) } _checkData(t) { const { colorType: e, channels: r, depth: i } = function (t) { const { channels: e = 4, depth: r = 8 } = t; if (4 !== e && 3 !== e && 2 !== e && 1 !== e) throw new RangeError(`unsupported number of channels: ${e}`); if (8 !== r && 16 !== r) throw new RangeError(`unsupported bit depth: ${r}`); const i = { channels: e, depth: r, colorType: Er.UNKNOWN }; switch (e) { case 4: i.colorType = Er.TRUECOLOUR_ALPHA; break; case 3: i.colorType = Er.TRUECOLOUR; break; case 1: i.colorType = Er.GREYSCALE; break; case 2: i.colorType = Er.GREYSCALE_ALPHA; break; default: throw new Error("unsupported number of channels") }return i }(t), n = { width: Fr(t.width, "width"), height: Fr(t.height, "height"), channels: r, data: t.data, depth: i, text: {} }; this._colorType = e; const a = n.width * n.height * r; if (n.data.length !== a) throw new RangeError(`wrong data size. Found ${n.data.length}, expected ${a}`); return n } writeCrc(t) { this.writeUint32(kr(new Uint8Array(this.buffer, this.byteOffset + this.offset - t, t), t)) } } function Fr(t, e) { if (Number.isInteger(t) && t > 0) return t; throw new TypeError(`${e} must be a positive integer`) } function Pr(t, e, r, i) { for (let n = 0; n < r; n++)e.writeByte(t[i++]); return i } function Mr(t, e, r, i) { for (let n = 0; n < r; n++)e.writeUint16(t[i++]); return i } var Hr; function jr(t) { return jr = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (t) { return typeof t } : function (t) { return t && "function" == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? "symbol" : typeof t }, jr(t) } function Wr() { Wr = function () { return e }; var t, e = {}, r = Object.prototype, i = r.hasOwnProperty, n = Object.defineProperty || function (t, e, r) { t[e] = r.value }, a = "function" == typeof Symbol ? Symbol : {}, s = a.iterator || "@@iterator", o = a.asyncIterator || "@@asyncIterator", h = a.toStringTag || "@@toStringTag"; function l(t, e, r) { return Object.defineProperty(t, e, { value: r, enumerable: !0, configurable: !0, writable: !0 }), t[e] } try { l({}, "") } catch (t) { l = function (t, e, r) { return t[e] = r } } function d(t, e, r, i) { var a = e && e.prototype instanceof g ? e : g, s = Object.create(a.prototype), o = new T(i || []); return n(s, "_invoke", { value: U(t, r, o) }), s } function f(t, e, r) { try { return { type: "normal", arg: t.call(e, r) } } catch (t) { return { type: "throw", arg: t } } } e.wrap = d; var c = "suspendedStart", u = "suspendedYield", _ = "executing", p = "completed", w = {}; function g() { } function b() { } function m() { } var y = {}; l(y, s, (function () { return this })); var v = Object.getPrototypeOf, k = v && v(v(O([]))); k && k !== r && i.call(k, s) && (y = k); var E = m.prototype = g.prototype = Object.create(y); function x(t) { ["next", "throw", "return"].forEach((function (e) { l(t, e, (function (t) { return this._invoke(e, t) })) })) } function A(t, e) { function r(n, a, s, o) { var h = f(t[n], t, a); if ("throw" !== h.type) { var l = h.arg, d = l.value; return d && "object" == jr(d) && i.call(d, "__await") ? e.resolve(d.__await).then((function (t) { r("next", t, s, o) }), (function (t) { r("throw", t, s, o) })) : e.resolve(d).then((function (t) { l.value = t, s(l) }), (function (t) { return r("throw", t, s, o) })) } o(h.arg) } var a; n(this, "_invoke", { value: function (t, i) { function n() { return new e((function (e, n) { r(t, i, e, n) })) } return a = a ? a.then(n, n) : n() } }) } function U(e, r, i) { var n = c; return function (a, s) { if (n === _) throw Error("Generator is already running"); if (n === p) { if ("throw" === a) throw s; return { value: t, done: !0 } } for (i.method = a, i.arg = s; ;) { var o = i.delegate; if (o) { var h = z(o, i); if (h) { if (h === w) continue; return h } } if ("next" === i.method) i.sent = i._sent = i.arg; else if ("throw" === i.method) { if (n === c) throw n = p, i.arg; i.dispatchException(i.arg) } else "return" === i.method && i.abrupt("return", i.arg); n = _; var l = f(e, r, i); if ("normal" === l.type) { if (n = i.done ? p : u, l.arg === w) continue; return { value: l.arg, done: i.done } } "throw" === l.type && (n = p, i.method = "throw", i.arg = l.arg) } } } function z(e, r) { var i = r.method, n = e.iterator[i]; if (n === t) return r.delegate = null, "throw" === i && e.iterator.return && (r.method = "return", r.arg = t, z(e, r), "throw" === r.method) || "return" !== i && (r.method = "throw", r.arg = new TypeError("The iterator does not provide a '" + i + "' method")), w; var a = f(n, e.iterator, r.arg); if ("throw" === a.type) return r.method = "throw", r.arg = a.arg, r.delegate = null, w; var s = a.arg; return s ? s.done ? (r[e.resultName] = s.value, r.next = e.nextLoc, "return" !== r.method && (r.method = "next", r.arg = t), r.delegate = null, w) : s : (r.method = "throw", r.arg = new TypeError("iterator result is not an object"), r.delegate = null, w) } function R(t) { var e = { tryLoc: t[0] }; 1 in t && (e.catchLoc = t[1]), 2 in t && (e.finallyLoc = t[2], e.afterLoc = t[3]), this.tryEntries.push(e) } function L(t) { var e = t.completion || {}; e.type = "normal", delete e.arg, t.completion = e } function T(t) { this.tryEntries = [{ tryLoc: "root" }], t.forEach(R, this), this.reset(!0) } function O(e) { if (e || "" === e) { var r = e[s]; if (r) return r.call(e); if ("function" == typeof e.next) return e; if (!isNaN(e.length)) { var n = -1, a = function r() { for (; ++n < e.length;)if (i.call(e, n)) return r.value = e[n], r.done = !1, r; return r.value = t, r.done = !0, r }; return a.next = a } } throw new TypeError(jr(e) + " is not iterable") } return b.prototype = m, n(E, "constructor", { value: m, configurable: !0 }), n(m, "constructor", { value: b, configurable: !0 }), b.displayName = l(m, h, "GeneratorFunction"), e.isGeneratorFunction = function (t) { var e = "function" == typeof t && t.constructor; return !!e && (e === b || "GeneratorFunction" === (e.displayName || e.name)) }, e.mark = function (t) { return Object.setPrototypeOf ? Object.setPrototypeOf(t, m) : (t.__proto__ = m, l(t, h, "GeneratorFunction")), t.prototype = Object.create(E), t }, e.awrap = function (t) { return { __await: t } }, x(A.prototype), l(A.prototype, o, (function () { return this })), e.AsyncIterator = A, e.async = function (t, r, i, n, a) { void 0 === a && (a = Promise); var s = new A(d(t, r, i, n), a); return e.isGeneratorFunction(r) ? s : s.next().then((function (t) { return t.done ? t.value : s.next() })) }, x(E), l(E, h, "Generator"), l(E, s, (function () { return this })), l(E, "toString", (function () { return "[object Generator]" })), e.keys = function (t) { var e = Object(t), r = []; for (var i in e) r.push(i); return r.reverse(), function t() { for (; r.length;) { var i = r.pop(); if (i in e) return t.value = i, t.done = !1, t } return t.done = !0, t } }, e.values = O, T.prototype = { constructor: T, reset: function (e) { if (this.prev = 0, this.next = 0, this.sent = this._sent = t, this.done = !1, this.delegate = null, this.method = "next", this.arg = t, this.tryEntries.forEach(L), !e) for (var r in this) "t" === r.charAt(0) && i.call(this, r) && !isNaN(+r.slice(1)) && (this[r] = t) }, stop: function () { this.done = !0; var t = this.tryEntries[0].completion; if ("throw" === t.type) throw t.arg; return this.rval }, dispatchException: function (e) { if (this.done) throw e; var r = this; function n(i, n) { return o.type = "throw", o.arg = e, r.next = i, n && (r.method = "next", r.arg = t), !!n } for (var a = this.tryEntries.length - 1; a >= 0; --a) { var s = this.tryEntries[a], o = s.completion; if ("root" === s.tryLoc) return n("end"); if (s.tryLoc <= this.prev) { var h = i.call(s, "catchLoc"), l = i.call(s, "finallyLoc"); if (h && l) { if (this.prev < s.catchLoc) return n(s.catchLoc, !0); if (this.prev < s.finallyLoc) return n(s.finallyLoc) } else if (h) { if (this.prev < s.catchLoc) return n(s.catchLoc, !0) } else { if (!l) throw Error("try statement without catch or finally"); if (this.prev < s.finallyLoc) return n(s.finallyLoc) } } } }, abrupt: function (t, e) { for (var r = this.tryEntries.length - 1; r >= 0; --r) { var n = this.tryEntries[r]; if (n.tryLoc <= this.prev && i.call(n, "finallyLoc") && this.prev < n.finallyLoc) { var a = n; break } } a && ("break" === t || "continue" === t) && a.tryLoc <= e && e <= a.finallyLoc && (a = null); var s = a ? a.completion : {}; return s.type = t, s.arg = e, a ? (this.method = "next", this.next = a.finallyLoc, w) : this.complete(s) }, complete: function (t, e) { if ("throw" === t.type) throw t.arg; return "break" === t.type || "continue" === t.type ? this.next = t.arg : "return" === t.type ? (this.rval = this.arg = t.arg, this.method = "return", this.next = "end") : "normal" === t.type && e && (this.next = e), w }, finish: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.finallyLoc === t) return this.complete(r.completion, r.afterLoc), L(r), w } }, catch: function (t) { for (var e = this.tryEntries.length - 1; e >= 0; --e) { var r = this.tryEntries[e]; if (r.tryLoc === t) { var i = r.completion; if ("throw" === i.type) { var n = i.arg; L(r) } return n } } throw Error("illegal catch attempt") }, delegateYield: function (e, r, i) { return this.delegate = { iterator: O(e), resultName: r, nextLoc: i }, "next" === this.method && (this.arg = t), w } }, e } function Kr(t, e, r, i, n, a, s) { try { var o = t[a](s), h = o.value } catch (t) { return void r(t) } o.done ? e(h) : Promise.resolve(h).then(i, n) } function $r(t) { return function () { var e = this, r = arguments; return new Promise((function (i, n) { var a = t.apply(e, r); function s(t) { Kr(a, i, n, s, o, "next", t) } function o(t) { Kr(a, i, n, s, o, "throw", t) } s(void 0) })) } } !function (t) { t[t.UNKNOWN = 0] = "UNKNOWN", t[t.METRE = 1] = "METRE" }(Hr || (Hr = {})); var Gr = function () { var t = $r(Wr().mark((function t(e) { return Wr().wrap((function (t) { for (; ;)switch (t.prev = t.next) { case 0: return t.abrupt("return", new Promise((function (t, r) { var i = new FileReader; i.onload = $r(Wr().mark((function e() { var n; return Wr().wrap((function (e) { for (; ;)switch (e.prev = e.next) { case 0: try { a = i.result, n = new Tr(a, void 0).decode(), t(new ImageData(new Uint8ClampedArray(n.data), n.width, n.height)) } catch (t) { r(t) } case 1: case "end": return e.stop() }var a }), e) }))), i.onerror = function (t) { return r(t) }, i.readAsArrayBuffer(e) }))); case 1: case "end": return t.stop() } }), t) }))); return function (e) { return t.apply(this, arguments) } }(), Yr = function (t) { return new Blob([(e = t, new Zr(e, undefined).encode())], { type: "image/png" }); var e }; return i })()));

errorHandling.scriptsLoaded.pngLib = true;